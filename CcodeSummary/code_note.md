## static

所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问，加了static前缀就会对其他源文件隐藏。

对于函数来讲，static 的作用仅限于隐藏（其他文件不可见），而对于变量，static 还有两个作用：

1、static的第二个作用是保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见，但我还是举一个例子。 

```c
#include <stdio.h>
int fun(void){
    static int count = 10;    // 事实上此赋值语句从来没有执行过
    return count--;
}
int count = 1;
int main(void)
{    
    printf("global/t/tlocal static/n");
    for(; count <= 10; ++count)
        printf("%d/t/t%d/n", count, fun());    
    
    return 0;
}

// 程序的运行结果是：
global          local static
1               10
2               9
3               8
4               7
5               6
6               5
7               4
8               3
9               2
10              1  
```

2、static的第三个作用是默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。

比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。

再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加’/0’太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’/0’。

## inline

我们看下面的函数，函数体中只有一行语句： 

```c
double Average(double total, int number){ 
    return total/number;
} 
```

定义这么简单的函数有必要吗？实际上，它还是有一些优点的：

第一，它使程序更可读；

第二，它使这段代码可以重复使用。但

是，它也有缺点：当它被频繁地调用的时候，由于调用函数的开销，会对应用程序的性能(时间＋空间效率，这儿特指时间)有损失。

例如，Average在一个循环语句中重复调用几千次，会降低程序的执行效率。

那么，有办法避免函数调用的开销吗？对于上面的函数，我么可以把它定义为内联函数的形式：


```c
inline double Average(double total, int number){
    return total/number;
}
```
函数的引入可以减少程序的目标代码，实现程序代码的共享。

函数调用需要时间和空间开销，调用函数实际上将程序执行流程转移到被调函数中，被调函数的代码执行完后，再返回到调用的地方。这种调用操作要求调用前保护好现场并记忆执行的地址，返回后恢复现场，并按原来保存的地址继续执行。对于较长的函数这种开销可以忽略不计，但对于一些函数体代码很短，又被频繁调用的函数，就不能忽视这种开销。引入内联函数正是为了解决这个问题，提高程序的运行效率。

**在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替换**。由于在编译时将内联函数体中的代码替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间开销上不象函数调用时那么大，可见它是以目标代码的增加为代价来换取时间的节省。

**总结**：

- inline函数是提高运行时间效率，但却增加了空间开销。

- 即inline函数目的是：为了提高函数的执行效率(速度)。

非内联函数调用有栈内存创建和释放的开销

在C中可以用宏代码提高执行效率，宏代码不是函数但使用起来像函数，编译器用复制宏代码的方式取代函数调用，省去了参数压栈、生成汇编语言的CALL调用、返回参数、执行return等过程，从而提高速度。

**使用宏的缺点**：

- 1）容易出错(预处理器在复制宏代码时常常产生意想不到的边际效应)

    例如：`#define MAX(a,b)    (a) > (b) ? (a) : (b)`

    语句`result = MAX(i,j) + 2 `却被扩展为`result = (i)>(j)?(i):(j) + 2`;

    但意却为`result = ((i)>(j)?(i):(j)) + 2`;

- 2）不可调试

- 3）无法操作类的私有数据成员

C++函数内联机制既具备宏代码的效率，又增加了安全性，且可自由操作类的数据成员。

关键字inline必须与**函数定义体放在一起**才能使函数真正内联，仅把inline放在函数声明的前面不起任何作用。因为inlin是一种用于实现的关键字，不是一种用于声明的关键字。

许多书籍把内联函数的声明、定义体前都加了inline关键字，但声明前不应该加(加不加不会影响函数功能)，因为声明与定义不可混为一谈。

**声明、定义和语句：**

- 声明：就是在向系统介绍名字（一个名字是一块内存块的别名），只是告诉编译器这个名字值的类型及宣告该名字的存在性，仅此而已。
- 定义：则是分配存储空间，即具有了存储类型。

- 语句：程序的基本组成部分，分可执行语句(定义是)和不可执行语句(声明是)。

**在正式编写程序语句前定义的一些全局变量或局部变量，在C中为声明，C++中为定义**。

例如：

```c
int  a; //在标C中为声明，是不可执行语句；在C++中为定义，是可执行语句
extern int a; //为声明，是不可执行语句   CWinApp  curApp;//对象定义是可执行语句
```

**使用内联函数时应注意以下几个问题：**

- 1） **在一个文件中定义的内联函数不能在另一个文件中使用。它们通常放在头文件中共享**。

- 2） 内联函数应该简洁，只有几个语句，如果语句较多，不适合于定义为内联函数。 

- 3） **内联函数体中，不能有循环语句、if语句或switch语句**，否则，函数定义时即使有inline关键字，编译器也会把该函数作为非内联函数处理。

- 4） **内联函数要在函数被调用之前声明**。

## volatile

volatile 提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有 volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。下面举例说明。在DSP开发中，经常需要等待某个事件的触发，所以经常会写出这样的程序： 

```c
short flag; 
void test() { 
    do1(); 
    while(flag==0); 
    do2(); 
}
```

这段程序等待内存变量flag的值变为1(怀疑此处是0,有点疑问,)之后才运行do2()。

变量flag的值由别的程序更改，这个程序可能是某个硬件中断服务程序。例如：如果某个按钮按下的话，就会对DSP产生中断，在按键中断程序中修改flag为1，这样上面的程序就能够得以继续运行。但是，编译器并不知道flag的值会被别的程序修改，因此在它进行优化的时候，可能会把flag的值先读入某个寄存器，然后等待那个寄存器变为1。如果不幸进行了这样的优化，那么while循环就变成了死循环，**因为寄存器的内容不可能被中断服务程序修改**。为了让程序每次都读取真正flag变量的值，就需要定义为如下形式： 

```c
volatile short flag; 
```

需要注意的是，没有volatile也可能能正常运行，但是可能修改了编译器的优化级别之后就又不能正常运行了。因此经常会出现debug版本正常，但是release版本却不能正常的问题。**所以为了安全起见，只要是等待别的程序修改某个变量的话，就加上volatile关键字**。 

volatile的本意是“易变的”

由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。比如： 

```c
static int i=0; 
int main(void) 
{ 
   ... 
   while (1) 
   { 
      if (i) do_something(); 
   } 
} 
/* Interrupt service routine. */ 
void ISR_2(void) 
{ 
   i=1; 
} 
```

程序的本意是希望ISR_2中断产生时，在main当中调用do_something函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致do_something永远也不会被调用。

如果将将变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。此例中i也应该如此说明。

一般说来，**volatile用在如下的几个地方：** 

- 1、**中断服务程序中修改的供其它程序检测的变量需要加volatile**； 

- 2、**多任务环境下各任务间共享的标志应该加volatile**； 

- 3、**存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义**； 

**另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实现，2中可以禁止任务调度，3中则只能依靠硬件的良好设计了**。 

volatile 的含义 

volatile总是与优化有关，编译器有一种技术叫做数据流分析，分析程序中的变量在哪里赋值、在哪里使用、在哪里失效，分析结果可以用于常量合并，常量传播等优化，进一步可以死代码消除。

但有时这些优化不是程序所需要的，这时可以用volatile关键字禁止做这些优化，volatile的字面含义是易变的，它有下面的作用： 

1）不会在两个操作之间把volatile变量缓存在寄存器中。在多任务、中断、甚至setjmp环境下，变量可能被其他的程序改变，编译器自己无法知道，volatile就是告诉编译器这种情况。  

2）不做常量合并、常量传播等优化，所以像下面的代码：  

```c
volatile int i = 1;
if (i > 0) ...
```

if 的条件不会当作无条件真。  

3）对volatile变量的读写不会被优化掉。如果你对一个变量赋值但后面没用到，编译器常常可以省略那个赋值操作，然而对Memory Mapped IO的处理是不能这样优化的。 

前面有人说volatile可以保证对内存操作的原子性，这种说法不大准确，其一，x86需要LOCK前缀才能在SMP下保证原子性，其二，RISC根本不能对内存直接运算，要保证原子性得用别的方法，如 atomic_inc。 

对于jiffies，它已经声明为volatile变量，我认为直接用jiffies++就可以了，没必要用那种复杂的形式，因为那样也不能保证原子性。 

---

## C/C++常见修饰符（inline&static&const&extern&volatile）

#### static

- 关键字static有着不同不同寻常的历史。起初，在C中引入关键字`static`是为了表示退出一个块后仍然存在的局部变量；随后，`static`在C中有了第二种含义：用来表示不能被其它文件访问的全局变量和函数。为了避免引入新的关键字，所以仍使用static关键字来表示这第二种含义。
- static的三个作用
    - ①控制存储方式（生命周期）：函数内部的static变量，即静态局部变量，因为是局部变量，已经是内部连接了。
        - 控制存储方式 ⟹ 静态存储区：持久性+默认值为0。
            - ①存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
            - ②在静态数据区，内存中所有的字节默认值都是`0x00`（对于整型为0；对于字符数组为`'\0'`），某些时候这一特点可以减少程序员的工作量。
        - static修饰局部变量
            - 一般情况下，局部变量是放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了；如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束 ⟹ 生命周期及其存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。
            - 在用`static`修饰局部变量后，该变量只在初次运行时进行初始化工作，且只进行一次。
    - ②控制可见性与连接类型（作用域）：static全局变量，因为是全局变量，已经是静态存储了。
        - 控制可见性 ⟹ 隐藏
            - 当我们同时编译多个文件时，所有未加`static`前缀的全局变量和函数都具有全局可见性（源程序中的其它文件也能访问）。
            - static修饰函数和修饰全局变量
                - 函数/全局变量只能用在它所在的编译单元
                - **编译单元**：当一个`.c`或`.cpp`文件在编译时，预处理器首先递归包含头文件，形成一个含有所有必要信息的单个源文件，这个源文件就是一个编译单元。这个编译单元会被编译成为一个同名的目标文件（`.o`或`.obj`），链接程序把不同编译单元中产生的符号联系起来，构成一个可执行程序。
        - 利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突；对于函数来讲，`static`的作用仅限于隐藏。
        - 静态全局变量，作用域仅限于变量被定义的文件中，其它文件中即使用`extern`（下文会介绍）声明也无法使用它；准确地说，作用域是从声明之处开始，到文件结尾处结束：在定义之处前面的同一文件的那些代码行也不能使用它，想要使用就得在前面再加`extern`。
    - ③C++类中的static成员
        - 设计思路：将和某些类紧密相关的全局变量或函数写在类里面，使其看上去像一个整体，易于理解和维护。
        - 访问方式：可以想访问普通成员函数和变量一样通过对象访问，但常直接用`类名::???`的方式访问。
        - 静态成员变量：必须在类声明体外的某个地方（一般是实现文件`.cpp`）初始化。静态成员变量本质上是全局变量，在类的所有实例对象中共享一份。
        - 静态成员函数：本质上是全局函数，并不具体作用于某个对象，不需要对象也可以访问。静态成员函数中不能访问非静态成员变量，也不能调用非静态成员函数。
- static全局变量 vs 普通全局变量
    - 全局变量本身就是静态存储方式，两者在存储方式上并无不同
    - 普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通（非静态的）全局变量在各个源文件中都是有效的；静态全局变量限制了其作用域，只在定义该变量的源文件内有效，在同一源程序的其它源文件中无效；由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起的错误。 如果在不同源文件中出现了用`static`修饰的同名全局变量，那么这些变量互不干扰。
    - 把全局变量改变成静态变量后改变了变量的作用域，限制了变量的使用范围。
- static局部变量 vs 普通局部变量
    - 把局部变量改变为静态变量后改变了变量的存储方式，即改变了变量的生存期。
    - static局部变量只被初始化一次，下一次访问依据上一次结果值。
- static函数 vs 普通函数
    - 只在当前源文件中使用的函数应该声明为内部函数（static函数），内部函数应该在当前源文件中声明和实现；对于可在当前源文件以外使用的函数，应该在一个头文件中声明，要使用这些函数的源文件（包括函数实现）要包含这个头文件

#### const

- 被`const`修饰的东西（变量/函数）都受到强制保护，程序中使用`const`可以预防意外的变动，在一定程度上提高程序的健壮性，但是程序中使用过多的`const`，可能加大代码的阅读难度。

- const修饰普通变量

    - C的`#define`预处理指令，只是简单的值替代，缺乏类型的检测机制；C++引入`const`关键字：

        ```c
        const datatype name=value;
        ```

    - 不仅满足了使用预处理指令的要求：①不可变性；②避免意义模糊的数字出现，方便参数调整和修改，同时：③编译器不为普通`const`常量分配存储空间，而是将它们保存在符号表中 ⟹ 编译期间的常量，没有了内存存储等操作，效率更高。
    - 用`const`修饰的变量（用来修饰函数的形参除外）必须在声明时进行初始化；一旦一个变量被`const`修饰，在程序中除初始化外对这个变量进行的赋值都是错误的。

- const修饰指针：指针常量 vs 常量指针

    - 指针本身也是一个变量，只不过这个变量存放的是地址而已。

    - 指针常量：是一个常量，这个常量本身是一个指针，即指针本身的值不可变，指针只能指向固定的存储单元 ⟹ 指针指向的变量的值（这个固定存储单元保存的值）是可以改变的。

    - 常量指针：是一个指针，这个指针指向的变量是一个常量，该变量的值不可变 ⟹ 指针本身的值是可以改变的，即指针可以指向其它存储单元。

        ```c
        // 指针常量
        int* const a;
        // 常量指针
        int const *a;
        const int* a;
        ```

    - `const`是一个左结合的类型修饰符，它与其左侧的类型合为一个类型修饰符。

- `const`修饰函数的参数

    ```c
    // 常量指针：以防意外改动指针指向数据内容
    void stringCopy(char* strDest, const char* strSrc);
    // 指针常量：以防意外改动指针本身
    void swap(int* const p1, int* const p2);
    // 非内部数据类型的引用传递
    void Func(const MyClass& a);
    ```

    - “值传递”函数将自动产生临时变量用于复制该参数，该输入参数无需保护；临时对象的构造、复制、析构都将消耗时间；内部数据类型不存在构造析构的过程，复制也非常快。
    - “引用传递”仅借用一下参数的别名而已，不需要产生临时对象；“引用传递”有可能会改变参数，可以通过`const`限定。

- `const`修饰函数的返回值

    ```c
    const char* getString(void);
    // 函数返回值采用值传递，加 const 没有任何意义
    const int getWidth(void);
    const Myclass& getObj(void);
    ```

- `const`限定类的成员函数

    ```c++
    class MyClass {
        int getXXX() const;
    };
    ```

    - `const`只能放在函数声明的尾部，大概是因为其它地方被占用了。
    - 只读函数：函数不能改变类对象的状态（只能由常量对象（实例）调用）；不能修改类的数据成员，不能在函数中调用其它非`const`函数。

- C和C++中的`const`有很大区别：在C语言中用`const`修饰的变量仍然是一个变量；而在C++中用`const`修饰后，就变成常量了。

    ```c
    const int n=5;
    int a[n];
    ```

    - 这种方式在C语言中会报错，原因是声明数组时其长度必须为一个常量；但是在C++中就不会报错。

#### extern

- 在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”

    - `extern`置于变量或者函数前，标识变量或者函数的定义在别的文件中，提示编译器遇到此变量或函数时在其他模块（其他`.o`文件）中寻找其定义。
    - 关于extern的作用域
        - 对外部变量的引用不只是取决于extern声明，还取决于外部变量本身是否能够被引用到，即变量的作用域：要求被引用的变量的链接属性必须是外链接的，通常是全局变量。
            - `extern`声明的位置对其作用域也有关系，例如在某个函数中的声明就只能在该函数中调用，在其它函数中不能调用。
    - 为啥要用extern？因为用extern会加速程序的编译过程，这样能节省时间。
        - 对其它模块中函数的引用，最常用的方法是`#include`这些函数声明的头文件，`extern`的引用方式要直截了当、简洁的多：想引用哪个函数就用`extern`声明哪个函数，这会加速程序编译，确切的说预处理过程，节省时间；在大型C程序编译过程中，这种加速会更加明显。
    - 正确使用extern共享全局函数/全局变量
        - 供其他文件调用的外部函数和变量在`.h`文件中通过`extern`修饰进行声明，在`.c`/`.cpp`文件的变量定义与函数实现与普通变量、普通函数一致；要调用该文件中的函数和变量，只需要把`.h`文件用`#include`包含进来即可。

- ```c
    file1.c
    // 声明全局变量
    int i, j;
    char c;
    void func() {
      //...
    }
    ```

- ```c
    file2.c
    // 外部变量声明
    extern int i, j;
    extern char c;
    void func1() {
      //...
    }
    ```

    - 对外部变量的声明和定义不是一回事。对外部变量的声明，只是声明该变量是在外部定义过的一个全局变量，在这里引用；而外部变量的定义，即对该全局变量的定义，则要分配存储空间；一个全局变量只能定义一次，却可以有多次外部引用。

- 在C++中extern还有另外一个作用：用于指示C或者C++函数的调用规范。

    - C++和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。
        - C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称（重命名），而C语言则不会，因此会造成链接时找不到对应函数的情况。
    - 在C++中调用C库函数，需要在C++程序中`extern "C"{...}`声明要引用的函数，这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。

- ```c
    main.cpp
    extern "C" {
      int func1();
      // 或者
      #include "func1.h"
    }
     
    int main(){
      func1();
    }
    ```

    - 在C++中导出C函数，用`extern "C"{...}`进行链接指定，告诉编译器，请保持我的函数名，不要进行任何重命名。

- ```c
    xxx.cpp
    extern "C" {
      int func1();
      // ....
    }
    ```

#### inline

- ```c
    #define expression(x,y) (x+y)*(x-y)
    ```

    - A. 形式和使用上像一个函数，使用预处理器实现，没有参数压栈等一系列操作 ⟹ 效率很高
    - B. 使用（说调用不太准确）它时，只是做预处理器符号表中的简单替换 ⟹ 无严格类型检查，返回值也不能被强制转换为可转换的合适的类型。
    - C. C++类及类的访问控制的存在，这种方式无法访问类的保护成员或私有成员。

- inline修饰全局函数，保留了上述方式的优点，又能有效避免相应的不足。

    - inline内联函数代码被放入符号表中，调用时直接进行替换（像宏一样展开），没有了调用的开销，效率也很高。
        - 栈空间是指放置程序局部数据也就是函数内数据的内存空间，系统下的栈空间是有限的，假如频繁大量地使用（递归死循环调用）就会造成因栈空间不足所造成的程序出错。
        - 函数被调用，函数入栈，即函数栈，会消耗栈空间（栈内存）。
    - 编译器像对待普通函数一样 ⟹ 参数类型检测…
    - `inline`成员函数 ⟹ 访问保护成员或私有成员

- inline内联函数函数体应简单

    - `inline`函数足够简单：不能包含复杂的结构控制语句（while/switch），不能出现递归。
    - 原因：内联函数会在任何调用它的地方展开，如果太复杂，代码膨胀（程序总代码量增大，消耗更多的内存空间）⟹⟹ 效率反而得不偿失。
    - 内联函数常用在类的`set/get`函数。

- inline函数声明和定义（实现）放在头文件中最合适

    - 省却每个文件实现一次的麻烦
    - 避免实现存在不一致的问题

#### volatile

- ```c
    volatile int i=10;
    int a=i;
    // 其他代码，并未明确告诉编译器，对 i 进行过操作
    ...
    int b=i;
    ```

    - `volatile`指出变量是随时可能发生变化的，每次使用该变量的时候都必须从其地址中读取，因此编译器生成的`int b=i;`的汇编代码会重新从变量 i 的地址读取数据放在变量 b 中；优化的做法（没有`volatile`）是：编译器发现两次从变量 i 读数据的代码间没有对 i 进行过操作，会自动把上次读的 i 的数据（一般的编译器可能会将其拷贝放在寄存器中以加快指令的执行速度）放在变量 b 中 ⟹ `volatile`可以保证对特殊地址的稳定访问。

- volatile与编译器优化

    - 提高执行速度的两个方面
        - 硬件级别的优化：由于内存访问速度远不及CPU处理速度，为提高机器整体性能，在硬件上引入高速缓存cache，加速对内存的访问；另外在现代CPU中指令的执行并不一定按照顺序执行（in-order），没有相关性的指令可以乱序执行（out-of-order），以充分利用CPU的指令流水线，提高执行速度
        - 软件级别的优化：一种是在编写代码时由程序员优化；另一种则是由编译器进行优化。编译器优化常用的方法有：
            - ①将内存变量缓存到寄存器；
            - ②调整指令顺序以充分利用CPU指令流水线，常见的是重新排序读写指令（可能是`load`/`store`指令）。
    - volatile总是与优化有关，编译器有一项技术叫做数据流分析，分析程序中的变量在哪里赋值？在哪里使用？在哪里失效，分析结果可以用于常量合并、常量传播等优化，进一步可以死代码消除。编译器对常规内存进行优化的时候，这些优化是透明的，而且效率很好；但有时候这些优化不是程序所需要的，这时可以用volatile禁止这些优化：
        - 不要在两个操作之间把`volatile`变量缓存在寄存器中：在多任务、中断等环境下，变量可能被其他程序改变。
        - 不做常量合并、常量传播等优化。
        - 对`volatile`变量的读写不会被优化掉：如果你对一个变量赋值但后面没用到，编译器常常可以省略那个赋值操作，然而万一这个赋值是对 Memory Mapped的 IO 资源（比如LEDs）进行操作呢！

- 一般说来，volatile用在如下几个地方：

    - 中断服务程序中修改的供其它程序检测的变量需要加`volatile`。
    - 多任务环境下各任务间共享的标志应该加`volatile`。
    - 存储器映射（Memory Mapped）的硬件寄存器通常也要加`volatile`说明，因为每次对它的读写都可能有不同的意义。

- 频繁地使用`volatile`很可能会增加代码尺寸和降低性能！

- 一个参数可能既是`const`又是`volatile`，比如只读的状态寄存器。







[杂货边角（4）：C语言static, inline, volatile, const等关键字解析](https://blog.csdn.net/roger_ranger/article/details/78864417)

[C/C++常见修饰符（inline&static&const&extern&volatile）](https://durant35.github.io/2017/07/06/programPearls_inline$static$const$extern$volatile/)

[inline与static的关系](http://www.cnblogs.com/xkfz007/articles/2370640.html)

[内联函数的使用及注意点](https://www.cnblogs.com/xkfz007/archive/2012/03/27/2420166.html)

[内联函数(inline Function)浅析](https://www.huliujia.com/blog/4e4824434d272ec7be2bcf85c04cb2e57be3690e/)
