{"./":{"url":"./","title":"简介","keywords":"","body":"简介 前言：软件编写模式是开发过程中的重要经验总结。灵活运用设计模式，一方面利于我们编写高质量的代码，另一方面也方便我们对代码进行维护。 C语言实现设计模式的几个利器有结构体，函数指针，利用数组实现多态。 文字底色： This text is {% em %}highlighted !{% endem %} This text is {% em %}highlighted with **markdown**!{% endem %} This text is {% em type=\"green\" %}highlighted in green!{% endem %} This text is {% em type=\"red\" %}highlighted in red!{% endem %} This text is {% em color=\"#ff0000\" %}highlighted with a custom color!{% endem %} This text is highlighted ! This text is highlighted with markdown! This text is highlighted in green! This text is highlighted in red! This text is highlighted with a custom color! "},"ORAN/":{"url":"ORAN/","title":"O-RAN","keywords":"","body":"O-RAN 总体架构与概述 什么是无线接入网RAN (Radio Access Network) 终端设备，如手机、电脑、智能终端等通过网络连接起来的通常方式有两种： 一种方式称为 “有线”：如网线、光纤、有线电视线。 另一种方式称为 “无线”：如果WiFi，WiMax，蓝牙，ZigBee，卫星通信，还有我们常听到的2G, 3G, 4G, 5G。 广义上讲，能够把无线终端连接通过无线的方式连接到网络中的设备组成的网络，都称为无线接入网RAN。为了进一步区分各种无线接入网，需要对无线接入网进一步的划分。 划分方法1： 专用无线接入网：特定的行业或部门面向内部服务而建立的无线接入网。如公安、军队、企业。 公众无线接入网：由电信运营商面向公共服务而建立起来的无线接入网，如2G/3G/4G/5G. 划分方法2： 利用免费的无线频谱接入：如WiFi，蓝牙。 使用授权的无线频谱接入：如2G/3G/4G/5G。 O-RAN中的RAN, 是指电信运营商如果中国移动、中国联通，中国电信，提供的2G/3G/4G/5G等公众无线接入网，我们暂称为狭义上的无线接入网RAN。后续提到的RAN就是这种狭义上的无线接入网。 无线接入RAN只为无线终端通过无线电磁波的方式连接到网络提供了手段，但如果终端要想相互间通信，还需要上图中的核心网。当然，核心网除了确保无线终端之间能够相互通信，还提供了计费、移动管理、与其通信网络互通、与互联网互通等功能。核心网和无线接入网共同组成公众移动/无线通信网。 ORAN联盟的组织架构 由AT&T、中国移动、德国电信、NTT DOCOMO和Orange于2018年2月成立，于2018年8月作为德国的实体成立。管理架构包括一个由15家运营商组成的运营委员会和一个由斯坦福大学教授Sachin Katti博士和中国移动无线技术首席科学家Chih Lin I博士共同主持的技术指导委员会。剩余的成员由每个技术工作组的主席和联合主席组成。工作组由操作员和贡献者组成。 工作组1: 用例和总体架构工作组。它全面负责O-RAN体系结构和用例场景，以及不同工作组的任务的划分、跨工作组的技术协调。 工作组2: 非实时运行的智能控制器和A1接口工作组。支持非实时智能无线资源管理、高层过程优化、RAN中的策略优化，并为近实时（Near RealTime）无线智能控制器(RIC: RAN Intelligent Controller)提供AI/ML(人工智能/机器学习)模型。 工作组3：近实时RIC和E2接口工作组。定义一个基于近实时无线电智能控制器（RIC）的体系结构，实现对RAN元素和资源的近实时控制和优化。 工作组4：开放前传（fronthaul）接口工作组。提供真正的开放前传接口，可以实现多供应商的DU-RRU互操作性。FrontHaul（前向回传）主要是从BBU（Building Base band Unit：基带处理单元）到RRU（Radio Remote Unit：射频拉远单元）或RRH（Remote Radio Head：射频拉远头）之间的连接。 工作组5：开放的F1/W1/E1/X2/Xn接口工作组。为这些3GPP定义的接口提供完全可操作的多供应商配置文件规范，是对3GPP现有接口规范的增强。 工作组6：云化和编排工作组。推动RAN软件与底层硬件平台的剥离与脱钩，并提供相关的技术和参考设计，使通用的商用硬件平台能够用于RAN部署的所有网元，包括CU和DU。 工作组7：白盒硬件工作组。这个工作组的目标是规范化、标准化、并发布一个完整的参考设计，以孵化一个实现分离的软硬件平台。 工作组8：协议栈参考设计工作。开发O-RAN中央单元（O-CU）和O-RAN分布式单元（O-DU）的软件架构、设计，以及相应的发布计划。（没有包括AAU） 工作组9：数据传输工作组。关注传输层，包括传输设备、物理介质和与传输网络相关联的控制/管理协议。 O-RAN需要开放5G系统的哪些接口？ （1）Fronthaul接口： 该接口在5G系统中是DU和RU的接口，4G系统中是BBU与RRU直接的接口，该接口的私有化，导致运营商必须采购同一设备商的DU和RU设备。 O-RAN首先需要开发的是该接口，使得所有的5G网元的接口都是标准的。 （2）RAN与网管系统NMS的接口： 封闭系统里，特定设备商的RAN只能由设备商自家的NMS管理，而网管接口关系到O-RAN系统运维的自动化和智能化的水平，该接口是O-RAN是否能够成功的关键。 在这里O-RAN定义了一个新的网元RIC，以及其与O-RAN现有网元直接连接的E2接口,RIC SMO的A1接口等。 O-RAN与v-RAN的区别以及演进线路 O-RAN的目标是RAN的接口开放化，O-RAN不一定是硬件的虚拟化，他强调的是硬件的白盒化，即设计开放。 v-RAN的目标是RAN硬件的虚拟化，虚拟化的vRAN不一定是开放的。 O-RAN和v-RAN之间有交集，也有错开的部分。 但RAN的虚拟化，能够促进O-RAN的实施： 通过RAN的虚拟化，供应商的软件和硬件被分离。软件将不再与特定于供应商的专用硬件绑定，RAN软件可以在虚拟机或容器中运行。 通过虚拟化，运营商可以通过通用处理器性能的周期性提升获得RAN系统性能的提升。 同时在虚拟机上运行，也便于O-RAN的功能软件的更频繁的升级、更易于安装。 还可以通过软件更新彻底改变原先的供应商， 这对O-RAN是一个很大的诱惑，可以弥补O-RAN在通用的虚拟平台上短期性能不足的问题。 因此O-RAN有一个最佳实践性演进路线： 设备商专用硬件RAN => 设备商vRAN => 设备商的开放RAN => 可替换开放RAN. ORAN快速概览与创业机会 Reference 美国力挺的Open RAN，真的能成功吗？ 通信-ORAN专题系列-new 通信-ORAN专题系列 ORAN专题系列-1：什么是开放无线接入网O-RAN - Cache One O-RAN Docs xRan Controller Integration 通信人工智能的下一个十年 "},"ORAN/1.ORAN_Architecture.html":{"url":"ORAN/1.ORAN_Architecture.html","title":"1. O-RAN 总体架构与概述","keywords":"","body":"O-RAN 系统架构 开放无线接入网O-RAN的“五化”目标 硬件白盒化：白盒是相对于黑盒而言的，就是开放和标准化网元硬件内部的功能模块以及硬件模块之间的接口，引入更多的厂家参与硬件的开发与生产，逐渐把专用硬件演变通用硬件，而直接使用现有的通用硬件是实现硬件白盒化最快捷的途径之一。 软件开源化：通过开源软件的方式实现网络功能。 接口开放化：所有的逻辑网元的的接口都进行开放，不同厂家的逻辑网元能够方便、轻松的进行对接。 网络功能的虚拟化：将网络节点的功能，分割成几个功能区块，分别以软件方式实现，不再拘限于特定的硬件架构。 网络网络的智能化：结合人工技术和大数据分析技术，对网络进行自动化部署、运营、维护、管理和优化以及宏观调控。 开放无线接入网O-RAN的总体架构 将按“自下而上”顺序的介绍各个逻辑网元的功能： O-RAN的运行平台 O-RAN的网络功能 O-RAN的智能管理平台 O-RAN的运行平台：开放的云基础设施平台O-Cloud O-Cloud是一个云计算平台，底层是由满足O-RAN要求的物理基础设施节点（如通用的计算机或专用硬件平台）和云平台软件、O-RAN相关的管理和编排功能三部分组成。 专有软、硬件平台 这里指：传统的无线接入网RAN原有的专有硬件和专有软件的平台。 即使在O-RAN中，在短时间内，也很难做到全部的硬件、软件都通用化，部分功能，如射频处理和新增的实时基带处理等还将运行在专有的软、硬件平台RU之上。 但基于专有硬件和Linux操作系统的嵌入式软件的部分“虚拟化”已经实现了。RU的虚拟化是未来进一步研究的方向之一。 通用软、硬件平台 通用硬件主要指基于X86的通用计算机硬件，通用软件主要指Linux这样的通用操作系统。 O-RAN一个重要的目标，就是尽可能的把现有RAN的功能从专有的硬件和专有的嵌入式操作系统平台上剥离，迁移到通用的硬件、通用操作系统、通用的云平台上，并尝试开放软件接口，甚至软件开源。 通用的云平台组件 包括虚拟机操作系统、虚拟机监视器、容器等。 O-RAN相关的管理和编排功能 （1）O-RAN网络节点的管理： ​ 提供诸如O-RAN基础设施节点的发现、注册、软件生命周期管理、工作负载生命周期管理、故障管理、性能管理和配置管理等功能 （2）硬件加速器管理 （3）O-RAN云架构部署 承载（host）和运行O-RAN网络功能相关的软件实体。 O-RAN网络功能：5G三大子系统之接入网RAN 这是O-RAN的核心，O-RAN的主体与核心功能都是在这里实现的，是在已有的5G RAN功能基础之上的扩展，包括Near-RT RIC, O-CU-CP, O-CU-UP, and O-DU和O-RU，下一节会对RAN内部的这些子功能进一步的探讨。 5G三大子系统之核心网Core 核心网络完成移动终端的接续、计费，移动性管理、相互通信，以及与网外设备进行通信（如互联网和固定电话网等）。在O-RAN标准中，并没有对5G的核心网进行扩展。 O-RAN的运营管理平台：5G三大子系统之网管子系统（服务管理和编排SMO） SMO的功能相当于传统的封闭的RAN接入网设备的网络运营和管理子系统OAM或NMS，即网管。 包括如下三大功能： 云基础实施OAM：云基础实施的操作、维护、管理 RAN OAM：无线接入网的操作、维护、管理 非实时的RAN智能控制器（Non RT RIC: Non Real Time RAN Intelligent Controller） 为了体现O-RAN系统的网管与传统的封闭式网管的不同，体现O-RAN运营的高度智能化、网络功能的服务化和可定制化, 给它取了一个新的名称：服务管理和编排（SMO）框架，正所谓，名副其实。 之所以称之为框架，是因为这里提供的，不是传统的固化、面向单一厂家的网管，而是可以被调用的服务（service），SMO是多种管理服务的整合。 在服务提供商的网络中，SMO提供服务远远超出对RAN管理的服务，还可以包括诸如：核心网管理服务、传输管理服务、端到端切片管理服务等内容。 注解： O-RAN系统的智能化管理框架SMO，在思想层面、设计层面上都与传统电信设备商的现有网管系统的有着重大的区别： 服务化：SMO提供的是对设备运营管理的各种服务，而不是综合化后的实际网管。实际的、具体的、网络运营管理功能，由上图中的网管实例1,2,N来实施的。 开放化：SMO服务框架是一个开放的运营管理平台，可以集成符合O-RAN规范的任何厂家的5G产品，可以应用符合O-RAN规范的任何厂家的5G网络运营管理软件。为5G进入定制化、垂直的工业领域提供了技术保障。 智能化：利用人工智能、虚拟化、云计算、大数据分析、边缘计算等技术，实现对网络设备和网络功能的快速重构、智能运营与管理。 在SMO平台上，可以开展各种定制的网管“店面”，管理和运营各种定制化的“5G系统或应用”。 外部系统 能够利用SMO提供的各种O-RAN管理和编排的服务，设计和编写管理和运营5G系统的各种应用。 同时，还可以为SMO提供丰富的历史数据作为智能管理和运营5G系统的参考，帮助SMO进行更加智能化管理和运营的服务。 开放无线接入网O-RAN中各个子系统的总体接口 NG接口(Next Generation, 即5G)---已有 核心网--控制面、数据面接口，是已有的5G接入网与5G核心网之间的标准接口。 O1接口 (Open 1接口)---更新 无线接入网--资源的管理接口 是SMO与O-RAN内部网元之间的新增的接口，用于SMO对O-RAN内部的逻辑网元进行智能化的管理和运营，如O-CU-CP, O-CU-UP, and O-DU和O-RU。 CU-CP, CU-UP, DU, RU都是5G系统已有的逻辑网元。因此该接口可能与3GPP的标准保持一致。 主要的管理功能有： 无线网络功能（PNF）的发现、软件管理（SM）、配置管理（CM）、故障管理（FM）、性能管理（PM）、通信监视（心跳）、日志管理（log）、文件管理。 O2接口(Open 2接口)---新增 “云”--资源的管理接口 是SMO与O-Cloud的之间新增的接口，用于SMO对云平台O-Cloud之上运行的各个O-RAN网络服务节点进行智能化管理与运营。 主要的管理功能有： 云资源的发现、创建、删除、扩容、缩容、性能管理PM、故障管理FM、通信监视、软件管理等。 Fronthaul m-plane接口---可选 RU--资源管理接口 所谓fronthaul m-plane，在5G系统规范中, 是指分布式单元DU与无线单元RU 之间的内部管理接口。 DU与RU之间，3GPP虽然对用于数据传输的CPRI接口和eCPRI接口进行了规范，但并没有对管理平面本身的接口协议进行规范，这个接口的协议规范留个给了各个设备厂家自行定义，并没有开放。 主要的管理功能有：“启动”安装、软件管理、配置管理、性能管理、故障管理、文件管理。 在O-RAN中，定义了O1接口来管理O-RU单元。为了与现有产品的后向兼容性，O-RAN希望设备厂家开放各自的fronthaul m-plane接口。 这样一来，O-RU就有两组不同的管理接口：O-RU O1接口与fronthaul m-plane接口，并且不同厂家的fronthaul m-plane接口规范还不一样。 通过两组接口对O-RU进行管理，称之为混杂（hybrid）模式，而通过单一的O1接口管理O-RU，称之为扁平（flat）模式。 A1接口---新增 无线接入网--非实时控制和优化接口 用于SMO对O-RAN内部的无线资源进行智能化和动态的细粒度的控制。 注解： 如果说O1接口是SMO与O-RAN之间纯管理平面的接口。 A1接口就是SMO对O-RAN内部控制平面实施的动态的、智能的控制性干预！ 是SMO对整个开放无线接入网的一种“宏观”调控。 无论对国家、还是企业，无论是计划经济还是市场经济，如何提高资源的利用率，如何提高资源的效率，如何对资源进行控制和优化，是一个永恒的话题。 原先的无线接入网，更多关注的是每个基站内部无线资源的微观的调控，而O-RAN中的SMO，更多是对整个无线接入网中所有无线资源进行的宏观调控。 而能够做到这一点的关键是：无线资源功能的云化和虚拟化！ O-RAN内部逻辑网元的整体架构 NRT-RIC（近实时的RAN智能控制器） 这在前面讨论刚刚，这是O-RAN新引入。 4G LTE的网元ENB 因为，在很长的一段时间内，5G不是独立组网SA，而是4G+5G的混合组网NSA，因此O-RAN无法把4G LTE ENB排除在外。 但考虑到LTE已经是成熟部署的网络，因此O-RAN没有对LTE ENB再进行进一步的切分，而是把ENB作为一个整体无线资源对其进行了扩展： O1接口：用于对O-ENB进行智能化的配置和管理。 E2接口：用于对O-ENB的无线资源进行控制。 5G NR的网元 其他, 都是5G系统定义标准的网元， CU-CP, CP-UP, DU, RU 5G的每个逻辑单元的功能，有多种方案，如下实例展示了其中的一种方案。 O-RAN对这些标准网元进行了开放性的扩展，以支持通过SMO对其进行智能化管理： O-RU（开放-无线单元）、 O-DU（开放-分布式单元）、 O-CU-CP（开放-集中单元-控制平面）、 O-CP-UP（开放-集中单元-数据平面）。 O1接口：用于对O-RAN内部网元进行智能化的配置和管理。 E2接口：用于对O-RAN内部网元的无线资源进行控制。 Open Fronthaul DU S-plane: 用于DU对RU的时钟同步。 Open Fronthaul M-plane：用于DU对RU的配置管理。 O-RAN无线资源控制的实时性类型与控制环的类型 在O-RAN中，对无线资源的实时性控制，进行了进一步的细分：非实时性、近实时性和实时性。 无线资源调度和控制环，是指从控制器实体发出控制指令，到被控制实体控制生效，最后到控制实体收到控制器实体的相应的整个环路。而控制环的类型，是根据控制环的实时性的类型来划分的。 Non TR: 非实时 发生在SMO对O-RAN子系统的无线资源的调度和控制，控制环的延时>1s。 Near RT: 近实时 实时性要求处于实时和非实时之间。发生在O-RAN内部的RIC对O-RAN内部无线资源的控制。控制环的延时>=10ms，而. RT：实时性 发生在DU和RU实体之间的无线资源调度和控制，控制环延时。 O-RAN对3GPP系统架构的影响 逻辑网元 O-RAN并没有对5G 3GPP定义的RU, DU, CU-CP, CU-UP, eNB这些逻辑网元进行更改，而是在这些既有的网元的基础上，增加了两个新的逻辑网元。 Non RT RIC（RAN智能控制器）：位于RAN接入网之外，RAN网络管理子系统SMO之内。 Near RT RIC（RAN智能控制器）：位于RAN接入网之内。 接口 除了与网管子系统的接口之外，O-RAN并没有对5G 3GPP定义F1, E1, X2, Xn，NG这些既有的逻辑网元的接口进行更改，只在此基础之上增加了新的接口：O1, O2, A1, E2. Fronthual M-plane接口比较特别，在5G中，这个接口是厂家私有接口，在O-RAN中，可选性的进行了开放。 协议面 U-plane: 无修改 C-Plane: 无修改, 增加了A1, E2接口。 S-Plane: 无修改 M-Plane: 改动非常大, 增加O1, O2接口，开放了Fronthual M-plane接口. "},"ORAN/2.ORAN_white_box.html":{"url":"ORAN/2.ORAN_white_box.html","title":"2. O-RAN 白盒化","keywords":"","body":"O-RAN 的硬件白盒化 软件的黑盒测试和白盒测试 1、软件的黑盒测试： 又叫功能测试，把待测试软件对象看成一个黑盒子，只关注软件的对外接口，完全不考虑程序内部的逻辑结构和内部特性，依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。 2、软件的白盒测试 有又叫结构测试，把测试软件对象看成一个打开的盒子，利用程序内部的逻辑结构及有关信息，设计或选择测试用例, 对程序的所有逻辑路径进行测试，通过在不同点检查程序状态，否与预期的状态一致。 5G协议栈功能切分选项与O-RAN白盒化 白盒化小基站经常提到Option6,7,8， 为啥没有Opiton1-5呢？ 从下图就可以看出原因。 选项1-8是5G协议栈的功能切分点。 O-RAN分离式基站，只使用了Option6-8，也就是说，在O-RAN中，最多把High-PHY放到O-RU中实现。 High-PHY之上的功能需放到O-DU或O-CU中。 当然，一体化O-RAN小基站，对应的是Option2. O-RAN 分体式小基站Option6硬件白盒化的参考架构 在5G系统中，把L1 PHY层进一步分成了High-PHY和Low-PHY。 High-PHY是指L1中，与DSP没有直接的强相关性软件实体。 Low-PHY是那些与DSP有强相关性的软件实体。 根据把High-PHY和Low-PHY部署DU或RU的方案不同，分为了4中选项： 如下称为Option6, Option7, Option8 以及 option7-8。 High-PHY和Low-PHY部署的方案不同，O-DU和O-RU之间的Front Haul接口协议也随之有差别，这是Front Haul比较复杂的一个最重要的原因，后续再用单独的章节讨论Front Haul接口协议的开放问题。 O-RU6的架构图 Ethernet：以太网交换控制器 Timing Unit：定时模块，包括本地晶振、本地锁相环和定时模块的参考时钟源，通常是IEEE 1588，也可以是GPS. Digital Processing：数字信号处理单元 RF Processing：模拟射频信号处理单元 RU RF处理单元: ANT: 天线，用于把模拟的电磁波发送到空气中。 PA：主要功能是功率放大，一般用在发射机的最后一级，把无线高频模拟载波信号的功率放大，功率越大，发送的距离越远。 LNA: 低噪声放大器，主要用于接收电路设计中。因为接收电路中的信噪比通常是很低的，往往信号远小于噪声，通过放大器的时候，信号和噪声一起被放大的话非常不利于后续处理，这就要求放大器能够抑制噪声。 Transceiver ADC/DAC: 数模转换器，用于把模拟信号转换成数字信号。 数字信号处理单元： Radio层数字信号处理单元 CFR: 是用来降低峰均功率比。 DPD: 是为了解决峰均功率比过大所导致的非线性问题。 L1 PHY数字信号处理单元 High-PHY Low-PHY nFAPIHandler： Open-nFAPI原本不是5G的规范，而是小基站small-cell论坛制定的L2和L1之间一个跨网元通信的开放的接口协议，以允许VNF（网络功能虚拟化）和PNF（物理网络功能）和之间的互操作性，并促进不同VNF之间的PNF共享。 这里VNF是L2，运行在O-DU上，PNF是L1,运行在O-RU上。 O-RAN 分体式小基站Option7硬件白盒化的参考架构 Option7分离式分层部署 O-DU与O-RU之间可以通过FHGW相连，称为分层部署。 在广覆盖的应用领域，推荐通过FHGW（fronthaul Gateway）网关相连。 通过FHGW的多播和汇集功能，大量节省O-DU和O-RU之间的数据传输带宽。 在此方案中，O-DU和O-RU之间，虽然是以太网连接, 但网关要进行多播和汇集的是IQ数据，因此通用的以太网交换机是不合适的，eCPRI是这里的一种方案，把IO数据承载在UDP/IP/以太网之上。 这个网关，这时候，也被称为eCPRI交换机，或eCPRI Hub。 Option7部署下Front Gateway（FHGW7）的硬件白盒化 （1）FHGW7的硬件架构图 前向和后向接口： 这两个接口，都是普通以太网接口。 数字信号处理单元： 虽然上述接口是以太网，但以太网之上承载的High-PHY与Low-PHY交换的数据格式却是5G新定义的。eCPRI就在诞生在这里。 很显然FHGW7不是普通的以太网交换机，而是专用的数字信号处理单元，需要处理上图中的eCPRI协议层和IO user data层的数据，通常需要FPGA或专用的DSP来实现。 既然eCPRI是承载在以太网, 或者说是UDP之上的，为啥不像FHGW6，直接使用普通的以太网交换或路由器，在O-DU和O-RU之间转发以MAC层或IP层数据呢？ 其根本原因是，为了降低O-DU和O-RU之间的数据传输流量，FHGW7还需要支持： 下行：支持蜂窝小区级（Cell）的数据的广播，而不是MAC层或IP层的广播 上行：支持蜂窝小区级（Cell）的数据的汇集，而不是MAC层或IP层的汇集 （2）FHGW功能模块图的接口 数字处理单元：蜂窝小区级IQ数据的广播和汇集功能。 POE++：power over ethernet，通过POE接口，可以给RU进行远程供电。 DC/DC：直流电源转换。 CLK: 本地时钟 Memory：DDR3/4内存 SPI: SPI flash，用于存放固件。 Debug interface：串口、Jtag调试口。 Ethernet: 以太网接口。 "},"ORAN/3.ORAN_OAM_OM.html":{"url":"ORAN/3.ORAN_OAM_OM.html","title":"3. O-RAN OAM操作维护管理架构","keywords":"","body":"O-RAN的OAM操作维护管理架构 O-RAN OAM参考架构的原则 原则能够帮助理解设计背后原因以及遵循的规则，O-RAN OAM架构设计的基本原则： RAN管理接口尽可能与3GPP规范保持一致，并尽可能的复用。 网络功能虚拟化NFV尽可能与ETSI(欧洲电信标准化协会)保持一致，并尽可能的复用。 O-RAN OAM参考架构，重点关注O-RAN扩展的部分和现有标准不支持异常处理部分，并尽量推动它们成为3GPP和ETSI的技术标准。 这就是O-RAN与3GPP之间的相辅相成的关系。 O-RAN OAM的基本参考架构 在《ORAN专题系列-2：O-RAN的系统架构》中，已经阐述了上述各个逻辑网元的功能和相应接口的功能。这里只简单的概述。 RU, O-DU, O-CU-CP, O-CU-UP, eNB: 这是5G 3GPP定义的标准RAN接入网的网元 O-Cloud：是虚拟的云基础设施，用于运行O-RAN系统中各个逻辑网元实体的软硬件功能。 SMO（服务管理与编排）：是OAM网管和非实时无线资源控制的子系统。主要功能有： 云基础实施OAM：通过O2接口对云基础设施进行操作、维护、管理。 RAN OAM：通过O1接口对无线接入网进行操作、维护、管理。 非实时的RAN智能控制（Non RT RIC）：结合人工智能技术，大数据分析技术，通过A1接口实施对O-RAN无线资源的非实时性的宏观调控和干预。 构成O-RAN架构的每个被管理的逻辑网元，实际上是一个虚拟的网络功能，可以部署在基于“云”的基础设施之上。 O-RAN SMO规范与3GPP OAM规范之间的映射关系 MDAS：management data analytics service（管理数据分析的服务） MDAF：management data analytic function（管理数据分析的功能） IDMS：intent driven management service (意图驱动管理的服务) FCAPS：Fault, Configuration, Accounting, Performance, Security 通过上图，可以看出 在传统的RAN OAM方面： O-RAN完全采用了3GPP的规范。由于AM计费是核心网的功能，安全SM是传输的功能，因此在OAM架构，没有把他们包含进来。 在“云”平台和虚拟网络功能方面： 3GPP没有既定的规范，O-RAN借用了ETSI欧洲电信标准化协会的标准。 在人工智能和大数据分析方面 3GPP没有既定的规范，但3GPP已经有工作组在研究并制定相关的技术标准， O-RAN也没有既定的规范，同样在积极的研究和制定相关的技术标准。 但O-RAN和3GPP在人工智能和大数据分析方面的侧重点是不一样的。 3GPP侧重于采集大量的无线通信网中的数据，并通过机器学习和大数据分析，对采集到的数据进行分析，并给出预测报告，以供OAM人员进行决策。 O-RAN在3GPP的基础之上，更近了一步，除了3GPP到达成的目标，还期望能够通过人工智能的算法，通过新定义的Non RT RIC和Near RT RIC这两个智能控制器，基于全网的实时分析的宏观数据分析，对RAN系统进行自动动态优化和动态宏观控制，而不是依赖网优人员来进行人工的优化和控制。 O-RAN部署选项与OAM模型 上述是O-RAN的逻辑网元，然而在实际部署中，不同的逻辑网元有可能部署在同一个物理网元上，为了优化设计，O-RAN又定义多个不同的OAM管理模型。 选项1：偏平模型 (Near-RT RIC) + (O-CU-CP) + (O-CU-UP) + (O-DU) + (O-RU) 扁平架构图与逻辑架构图的区别，就是所有的是虚线接口，全部变成实线接口。 在扁平架构中，构成O-RAN架构的每个被管理的逻辑网元，包括O-RU，都作为一个独立的实体，使用独立的、公开的O1通信接口与SMO进行通信。 在此中，O-RU的地位得到了提升，不再接受O-DU配置和管理，而是直接受SMO的配置和管理。但O-RU还需要通过开放的S-Plane接口，从DU获取同步时钟(比如PTP 1588时钟, NTP时间)。 在这个架构中，被管理的逻辑网元实际上是分布式地部署“云”基础设施之上的。 选项2：分层管理架构模型 (Near-RT RIC) + (O-CU-CP) + (O-CU-UP) + (O-DU) 这里的分层，主要针对的是O-RU管理分层, 而不是其他逻辑网元。 分层管理架构模型与扁平模型的区别是，在该架构中，O-RU不受SMO O1接口的管理，O-RU只接受O-DU通过open fronthaul M-plane的管理，这是传统的4G/5G的管理模式。 SMO只能通过O-DU的O1接口，间接的管理O-RU。这就是分层的含义。 选项3：混合管理架构模型 (Near-RT RIC) + (O-CU-CP) + (O-CU-UP) + (O-DU) + (O-RU) + (O-RU) 在此模型中，O-RU接受O-DU和SMO的双重管理，并且都是使用的Open Fronthaul M-Plane的管理，而不是O1接口。 双重管理的麻烦就是O-RU和SMO的信息同步问题。 选项4：单一的集中模型 （Near-RT RIC + O-CU-CP + O-CU-UP + O-DU + O-RU） 在这种模型中，所有的逻辑网元，集中部署在一起，对外只提供统一的SMO O1 选项5: (Near-RT RIC + O-CU-CP) + (O-CU-UP) + (O-DU + O-RU) 选项6： 选择7: (Near-RT RIC + O-CU-CP + O-CU-UP) + (O-DU + O-RU) 选项8: （Near-RT RIC） + (O-CU-CP + O-CU-UP) + (O-DU + O-RU) "},"ORAN/4.ORAN_RIC.html":{"url":"ORAN/4.ORAN_RIC.html","title":"4. O-RAN 近实时无线接入网智能控制器RIC的架构","keywords":"","body":"O-RAN 近实时无线接入网智能控制器RIC的架构 4G/5G非O-RAN网络架构下的无线资源管理RRM，不过是RIC的前世 L1, L2, L3： 完成了无线接入网4G/5G分层协议控制面的功能。 RRM无线资源管理：它是O-RAN中Rear RT RIC的A1功能的前身 对移动通信系统的空中接口资源的规划和调度，包括访问控制、信道分配控制、功率控制、负荷管理、移动性管理、小区间干扰协调、无线承载控制、切换控制等。 RRM能够跨越不同的协议层，对无线资源的信息收集、配置管理和优化控制。 OAM: 它是O-RAN中Rear RT RIC的O1接口功能的前身。 负责单一gNB本地的操作维护管理，并与操作维护管理中心的网管系统NMS进行通信。 NMS: 它是O-RAN中SMO的前身。 网络管理系统，负责RAN系统中所有的gNB的操作维护管理。 SON(Self-Organized Networks): 它是O-RAN系统中Non RT RIC功能的前身。 是NMS系统的一个子模块，其主要思路是实现无线网络的一些自主功能，减少人工参与，降低运营成本。 5G O-RAN网络架构下的Rear RT RIC, 不过是4G/5G RRM的今生 Near RT RIC(RAN Intelligent Controller)：近实时无线接入网智能控制器。 它完成类似4G/5G系统中的无线资源管理RRM的功能，但在原先的RRM能力的基础之上，进行了增强： 把NMS中SON的功能剥离出来，成为SMO中的None RT RIC。 把gNB中无线资源控制RRM的功能中剥离出来, 成为一个具有独立功能逻辑网元实体Real RT RIC。 把RRM原先与NMS/OAM的接口独立出来，变成了RIC的A1接口。 把RRM原先与L1、L2、L3的接口独立出来，变成了RIC的E2接口。 虽然RIC在实际部署时，可以与O-CU部署在一起, 但逻辑上讲，RIC是一个独立的网元，独立于单个的CU, DU, 因此可以在更宏观的层面, 综合全网的CU, DU进行“宏观”的调控。 RIC增加了人工智能技术，使得RIC更加的 ，如利用机器学习的学习和预测功能。 Rear RT RIC功能模块 RIC内部架构采用经典的、基于web的、服务器应用程序的三层的架构模型：数据层、逻辑业务层和表示层。 第一层：数据层 Database：分布式数据库 数据库，用于存放UE上下文相关的信息、无线资源控制相关的信息。 分布式，是指数据库的存储与Near RT RIC不一定在同一个服务器上，数据库可基于云基础架构而部署。 Shared Data Layer：共享数据层SDL 是对底层数据库的封装，简化了上层应用对数据库的访问。 第二层：业务逻辑层 xApp Subscription Management：订阅管理 xApp与E2的节点（ CU、DU、RU）通信采用的是订阅机制。 订阅管理通过注册/订阅和访问控制管理微服务xAPP。xAPP只有向E2的节点订阅成功后，才能收到E2节点发送的信息，xAPP才能访问和控制E2节点。 Conflict Mitigation：冲突缓解 无线资源管理的控制对象可能是小区、UE或承载。而无线资源控制的功能包括接入控制、承载控制、切换控制、QoS控制、资源分配，这些功能是通过修改控制对象的一个或多个参数来完成的。因此多个微服务应用程序调整的参数之间可能会发生冲突，甚至可能是反向的参数配置。 这就需要对冲突进行控制和管理，以避免CU、DU、RU这些节点无所适从，行为混乱。 这是RIC实现的一个难点之一。 Security：安全 防止恶意的xAPP滥用无线网络信息，增加网络的安全性。 Management Services：管理服务(O1接口) （1）xApp生命周期管理 （2）FCAPS: 故障、配置、计费（不需要）、性能和安全管理 Messaging Infrastructure：消息基础设施 它在Near RT RIC内部节点之间提供低延迟的消息传递服务。 xApp：微服务应用程序 一个个独立的应用程序，每个应用程序可能由一个或多个微服务组成。 这些应用程序只有在运行时，才识别使用哪些数据以及它提供哪些数据。 与传统的封闭式、单体式程序的服务提供商不同，这里引入了最新的软件架构：微服务软件架构。 关于微服务以及微服务的软件架构在RIC中应用，在后续的文章中再进一步的探讨。 在Near RT RIC架构中，xAPP可以由第三方公司提供，xAPP的标准接口使得xAPP非常容易的集成到Near RT RIC系统中。xApp的引入，为RIC打开了一扇对外开放的窗，为第三方公司参与到O-RAN的生态中来，提供了技术上可能性。 设计出符合某种特定的应用场景下的特定服务（类似单体式应用程序下的功能库，如图形库等，如android平台上的各种百花齐放的应用程序）是第三方专长公司的价值所在。 传统的电信设备商，如Nokia在RIC这个逻辑网元上，扮演什么角色呢? 或许，Nokia期望成为xApp+RIC平台+RAN接入网，甚至整个生态的集成商，成为RIC平台的提供商。然而,就RIC平台而言，传统的电信设备上，除了在RIC的冲突管理模块有一定的技术优势外，在其他模块上，是乎没有任何的技术优势。结果如何，拭目以待。 第三层：表示层 如果把RIC作为一个系统，表示层就是O1 termination和 A1 termination，它们用来终止SMO Non RT的数据Http请求，然后分发到内部的各个xApp服务上。 如果把O-RAN作为一个系统，表示层就是SMO Non RT，而IE浏览器就是客户端。 Rear RT RIC的对外接口 这些接口在O-RAN的系统架构和O-RAN OAM系统架构中讨论过，在这里不再深入。 需要说明和强调的是： 这里接口，采用的是：轻量级、低耦合、可伸缩、可定制的基于Http的通信协议。 E2接口： 通过该接口，Non RT RIC实现对多个O-CU-CP、O-CU-UP、DU、O-eNB的无线资源的监控、配置、管理和控制。 O1接口： 通过该接口，Non RT RIC实现对多个 RT RIC的无线资源的配置、管理。 A1接口： 通过该接口， Non RT RIC实现对多个 RT RIC的无线资源的监控和控制。 为xApp开放的API接口 我们说，RIC提供了一种开发的平台，便于能够提供特定场景下的无线资源智能控制的算法和服务的第三方xAPP公司，方便和轻松得把他们的xAPP服务集成到RIC系统中。 这就意味着，RIC平台必须为xApp开放其内部的接口，以便于xApp从RIC平台获取信息，并对O-RAN进行控制。 这些开放的接口包括： A1相关的接口 xApps根据非RT-RIC通过A1接口传输的策略或丰富信息或两者提供增值服务。 通过此接口，xApps可以完成与A1 termination的信息交互。 E2相关的接口 通过此接口，xApps可以完成与E2 termination的信息交互。 Management相关的接口 （1）xApp生命周期的管理 （2）机器学习模型的部署请求、更新请求、卸载请求等接口。 （3）常规的配置管理、故障管理等。 共享数据访问层SDL接口 该接口提供了一种简单而灵活的存储和检索数据的方法，同时隐藏了数据库的类型和位置、数据库层的管理操作（如高可用性、可伸缩性、负载平衡）等细节。 该接口还允许多个xApp相互独立地访问数据。 Control接口 该接口提供了xApp与负责控制功能的实体（如冲突缓解、xApp订阅管理）之间交换与控制相关的信息。例如，来自xApp的分析结果、决策或请求，可以通过接口进行传输，以缓解冲突、xApp订阅管理或其他必要的功能。 本节结束语： RIC是O-RAN提出的一个新的逻辑网元，通常与CU一起部署在云端。是对传统的无线资源管理RRM的拆分与重写汇聚， 综合了无线资源管理RRM、切片管理、服务水平协议SLA与Qos、机器学习与预测、微服务架构、云部署、Sass、与移动边缘云计算MEC的协同等技术, 从而实现对5G无线接入网提供近实时的智能控制。 这是O-RAN非常核心的网元，无论是运营商，还是设备商，对它对报以厚望，后续还讲进一步探讨。 RIC的位置与使命 RIC: RAN Intelligent Controller RIC是对传统的无线资源管理RRM的拆分与重新汇聚， 它综合了无线资源管理RRM、切片管理、服务水平协议SLA与Qos、机器学习与预测、微服务架构、云部署+Paas+Sass、移动边缘云计算MEC的协同等技术, 从而实现对5G无线接入网提供近实时的智能控制。 RIC是O-RAN提出的一个新的逻辑网元，处于封闭RAN的最边缘，通常与O-CU一起部署在云端。 与RAN传统的其他网元不同，RIC诞生在“云”之上，拥有“云原生”很多属性和特点，同时又承担这对封闭RAN智能控制的职责，注定这是一个新与旧的融合体，注定这里会涌现出新的想象空间，注定这里会诞生新的机会。 部分传统的电信设备商正在与运营商联手，以RIC作为切入点，试图建立一个更加开放的、更加智能的无线接入网； 并通过试图引入大量的第三方xApp微服务提供商，建议一个新的O-RAN的生态环境。 “云”的基本概念 RIC是O-RAN新定义的网元，因此它没有历史包袱，从诞生那刻起，就在“云”上，RIC的部署完全遵循“云”计算的服务模式：IaaS、PaaS和SaaS。 把原先黑盒式、封闭的式RAN设备提供商的打包服务，转换成开放的、分层的增值服务模式，尽可能的利用已有的开放的云平台，为运营商提供有价值的增值服务。因此，有必要先澄清几个基本的“云”概念。 什么是云 相对于单台计算机或单个嵌入式设备而言的，“云”实质就是一个网络。 但“云”又不仅仅是网络。网络是把单个计算机连接起来，“云”是把连接起来的海量的机器协同起来，一起完成计算机最本质的两件事情： 计算与存储。把海量的单个计算机协同起来的“云”具有海量的计算能力和海量的存储能力，并能够按需进行计算能力和存储能力的扩展和伸缩，这是单台计算机和嵌入式设备无法比拟的。 “云”计算 最初的云计算是分布式计算的一种，指的是先通过“云”将巨大的数据计算处理程序分解成无数个小程序，然后，再通过多部服务器组成的“云”进行处理和分析这些小程序，最后把得到的结果返回给用户。 现阶段所说的云服务已经不单单是一种分布式计算，而是分布式计算、效用计算、负载均衡、并行计算、网络存储、热备份冗杂和虚拟化等计算机技术混合演进的多种计算的综合。 “云计算”中的计算机群，就像一个庞大的人类社会，分时、分工地合作完成各项活动。 “云”计算服务的三种模式 单台计算机为单个用户提供独占式的计算服务。 单台服务器为多各用户提供分时复用的计算服务。 “云”为海量的用户可以提供定制化的计算服务，可以定制CPU, 定制内存，定制操作系统，定制软件等等，行业内把各种定制化的“云”服务大致分进行分类，按照传统的分层的方法，自底向上把这些服务分为：IaaS、PaaS和SaaS。 IaaS（Infrastructure as a Service）：基础架构即服务 就是云服务的提供商，把IT基础设施作为一种服务通过网络对外提供了客户。 IT基础设施包括虚拟的云服务器、虚拟的云存储器、虚拟的交换机等这些硬件设备。 操作系统最初作为PaaS平台服务提供给客户，但随着云服务的完善和发展，操作系统、虚拟网络、虚拟的存储器、分布式文件系统这些单机操作系统提供的软件功能，也成为了基础实施的一部分。 PaaS是（Platform as a Service）：平台即服务 就是云服务的提供商，把IT云平台作为一种服务通过网络对外提供了客户。 平台最初只是虚拟机的操作系统，但随着操作系统作成为基础设施的一部分，平台也进一步的上移，现在的平台通常是IT云平台，除了虚拟硬件和操作系统外，还包括应用程序的开发平台、Web应用开发框架、并行计算的平台、机器学习平台、特定的业务开发平台等。平台，即开发和运行应用程序的框架。 SaaS: Software-as-a-Service（软件即服务） 就是云服务的提供商，直接把业务软件作为一种服务通过网络对外提供了客户。 SaaS平台供应商将应用软件统一部署在自己的服务器上，客户可以根据工作实际需求，通过互联网向厂商定购所需的应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得Saas平台供应商提供的服务。 软件的品种繁多，有通用软件，如云办公软件，也有像政府、医疗、交通、金融、企业等所需要的专业性的行业软件，如微软提供的云医疗诊断软件。 客户端： 客户通过轻量级的浏览器客户端或手机终端，访问部署在云上的软件。 IaaS、PaaS和SaaS的成熟，已经改变了传统软件的方方面面： 软件的开发模式: 软件开发商、软件开发团队或个人，无需要投入大量的资金购买大量的用于软硬件开发的设备等生产资料，也无需要从无到有地手把手的搭建软件的开发环境。可以从云服务商那里直接租用PaaS平台作为自己的软件开发平台，节省了大量的软件开发成本和办公成本。 软件的部署模式：目标软件的部署也变得轻松，大量的应用场合，无需开发专用的嵌入式硬件平台，也无需要在嵌入式硬件平台上开发嵌入式操作系统和中间件等平台软件，目标业务软件直接部署在PaaS之上，软件开发者只需要关注业务软件本身；另外，由于业务软件脱离了专用的嵌入式硬件，而直接部署在虚拟的“云”上，软件的部署变得异常的轻松和方便，极大的节省了大量的软件开发成本的同时，也极大的节省了业务设备本身的成本。 软件的使用模式：软件的使用者，无需要登录到每台机器上使用软件，可以通过轻量级的IE浏览器远程使用软件，极大的提升了软件的使用效率。 RIC出生在“云”上 传统的RAN设备，是专用的嵌入式设备，有专用的硬件电路、专用的硬件驱动程序、嵌入式Linux操作系统，厂家特定的中间件软件、厂家特有的RAN协议软件等等。 而RIC软件，并非运行在嵌入式设备中，而天生运行在“云”上，遵循者“云”服务的理念。 按照云服务的三种形态分类，RIC也是以“云”服务的方式，由设备商提供给运营商或特定的行业用户的。 RIC IaaS：RIC基础设施服务 RIC直接把“云”服务商提供的基础设施IaaS和云平台PaaS，作为RIC的IaaS. Docker：是一个开源的应用容器引擎，让开发者把他们的应用程序以及依赖库打包到一个可移植的镜像文件中，然后发布到任何流行的 Linux或Windows 机器上。Docker是一个轻量级的虚拟机环境。 Kubernetes：简称K8s，是一个开源的，用于管理云平台中多个主机上的、容器化的应用，它的目标是让部署容器化的应用简单并且高效，它提供了应用部署，规划，更新，维护的一套机制。 Generic platform service：这是通用的“云”计算平台PaaS。 RIC PaaS：近实时的RIC平台服务 RAN智能控制的业务平台，用于运行第三方的RAN智能控制应用程序xApp。 这部分由数据库、E2 terminal、xApp、管理器等组件或服务组成。RIC内部详细的架构，参看《ORAN专题系列-10：5G O-RAN 近实时无线接入网智能控制器RIC软件架构》 近实时的RIC平台服务，是RIC的核心，也是O-RAN生态系统的最核心组成之一。 近实时的RIC平台服务，秉承着“平台即服务”的理念，为电信运营商或特定的行业用户提供了一个能够运行各种RAN智能控制软件的运行平台。 因此RIC平台是一个类似Android的开放的平台，允许第三方公司自由的开发具有自己特色RAN智能控制应用的xApp，只要遵循开放的接口标准，第三方的RAN智能控制应用程序xApp就可以在此平台上运行，实时地对O-RAN中的网元进行智能控制，这为第三方参与到O-RAN生态中提供了一定的技术保障。 RIC SaaS：RIC应用软件服务 软件即服务，这里的软件就是xApp，5G的RAN切片和特定的行业应用，为xApp提供了需求层面的土壤。 不同行业对RAN系统无线资源的管理策略是不相同的，O-RAN把此类应用的算法和代码实现从传统的运营商中剥离了出来，留给了第三方开发者。 本节结束语： 虽然O-RAN定义了RAN的开发标准，但要实现RAN的完全的开放，还有很长的路要走。RIC为RAN的开放打开了一扇窗，RIC在RAN一时无法完全开放的情况下，为RAN的开放迈出了实质性和关键线性的一步。 RIC把RAN开放到什么程度的控制权利留给RAN的设备供应商，允许RAN的设备供应商有条件、有步骤的、灵活的开放其内部无线资源。同时提供了一种开放的平台，允许第三方xApp公司，基于RAN设备开放的功能，开发特定业务场景下的无线资源智能制的应用程序。 微服务架构在5G O-RAN RIC中的应用 微服务架构的演进 单体应用程序架构 特点： 软件的所有功能集成在同一个软件包中，整体部署在服务器中运行。 优点： 在业务发展初期，为了快速落地应用，满足客户需求，一般会使用All in One的单体架构， 也是小项目的首选，开发成本低，架构简单。 缺点： 项目复杂后，模块与模块之间的交互与耦合就会很严重，很难扩展与维护，扩展成本高。 模块由于存在直接或间接的调用关系，编程语言也受限制。 所有的服务胶合在一起，没有分离，任何一点小的改动，都需要重新发布整个软件包。 新的技术很难在单体架构中实施。 注解： 这是典型的RAN系统中任一网元的传统的软件架构，导致组件间高度耦合。 垂直应用程序架构 特点： 对于单体架构进行拆分，拆分成几个垂直的独立的单体架构的子应用程序， 子应用程序之间尽量相互独立，没有交互。 单体架构的应用程序如果需要通信，则采用进程间通信实现。 优点： 架构简单，只是单体架构的复制。 避免在原有单体架构上做无限的功能扩充，避免了单个应用程序内部变得过于复杂和臃肿。 新增单体可以采用新的技术实现，不必受限于原有系统。 缺点： 不同应用程序之间有公共代码的实现的冗余，长此以往，公共代码就有多份备份，会导致资源的浪费。 不同应用程序之间出现动态数据的冗余，不同应用程序之间需要进行数据的同步。 且存在大量的重复代码拷贝及模块功能需大量重复造轮子的情况 SOA面向服务的架构 特点： 面向服务的体系结构已经逐渐成为IT集成的主流技术 一个服务定义了一个相对独立、自包含、可重用的业务功能。 服务间一般通过企业服务总线（ESB）的方式组装起来，对外提供更复杂的服务，满足客户更多样化的需求。 ESB是传统中间件技术与XML、Web服务等技术结合的产物 优点： 提高了系统的可复用性、解决冗余代码 通过ESP通信，减少模块之间的耦合 缺点： 系统/应用与服务之间的界限不清晰，不利于开发 ESP服务接口不固定，不利于系统维护 服务抽取的粒度过大。 微服务架构：（大平台） 特点： 微服务架构是一种部署在“云”中的应用程序的架构模式， 提倡将系统各个功能，抽象出来，变成一个个独立的细小服务， 每个独立的小服务可以独立部署，因此细小服务是自带上下文的。 微服务之间采用基于Http协议的轻量级的通信机制。 应当尽量避免统一的、集中式的服务管理机制。 每个独立的小服务可以选择适合的编程语言和工具进行独立构建。 优点： 拆分粒度比较小，便于独立开发、部署、维护。 适用于互联网快速的更新迭代。 每个微服务可以通过独立的技术（编程语言或其他工具）实现 UI和微服务间采用轻量级的HTTP协议进行通信。 缺点： 微服务太多，达到成千上万个，对微服务框架和微服务的治理平台要求较高。 把系统拆分的一个个独立的小服务的技术要求和难度大。 O-RAN RIC的架构及微服务应用程序xApp 在上述RIC的架构中，RIC PasS的服务，是以微服务的方式提供。 当然，RIC PasS还包括微服务的开发平台、运行平台和治理平台。 而xApp是第三方开发的应用程序，基于微服务架构的应用程序，主要利用RIC PasS微服务提供的RAN系统的数据，进行特定行业或特定领域场景下对RAN资源进行控制。 本节结束语： 微服务架构是新的软件架构，在互联网中得到了普遍的应用，而电信设备商的软件架构基本还停留在最初的单体程序架构上，因此电信设备商要想大幅度减少软件的发布周期，提升软件从开发到发布再到部署的整体效率，不仅仅需要组织架构的革新、软件开发流程的革新、IT基础设施的革新、管理人员和开发人员（劳动者）思维方式的变革、还包括目标系统（劳动对象）软件系统架构的革新。 "},"ORAN/5.ORAN_netconf.html":{"url":"ORAN/5.ORAN_netconf.html","title":"5. O-RAN FrontHaul前传接口的网络配置管理协议netconf","keywords":"","body":"O-RAN FrontHaul前传接口的网络配置管理协议netconf 前言 前传接口（FrontHual）是传统的BBU与RU之间的接口，在O-RAN之前，前传接口虽然定义了物理连接的CPRI接口规范标准，但CPRI之上承载的M plane的配置管理数据格式，却是设备厂家私有的。 有基于TCP的、有基于UDP的，有基于http协议的，自定义格式的，总之，不同的厂家，没有统一的标准。 O-RAN的一个重要的目标就是把这个私有接口开放化、标准化。 这就需要有这样一个标准的网络配置管理协议，能够满足下面的几个重要的需求： （1）定义网络设备的配置和管理数据的承载和传送，如TCP, UDP, HTTP, SSL, SSH （2）定义网络设备的配置和管理数据的流程控制和操作，如get，set，notify操作。 （3）定义网络设备的配置和管理数据的数据格式与模型，即管理数据的数据结构，数据的数据必须支持动态编程，而不能是静态的、不可伸缩的。 SNMP是传统的网络管理协议，但这样的协议，不太适合现代软件定义网络网络需求，不符合动态可伸缩性的要求，无法承担如此重任。 在O-RAN中，采用了netconf协议+Yang数据建模语言共同承担上述的三个职责。 其中netconf承担了上述（1）和（2）职责；Yang承担了（3）的职责。 NETCONF概述与协议架构 NETCONF概述 NETCONF = The Network Configuration Protocol NETCONF是由IETF在2003年5月成立了Netconf工作组，提出一个全新的基于XML的网络配置（NETCONF）协议。 NETCONF协议是完全基于XML 之上的，所有的配置数据和协议消息都用XML 表示。 XML可以表达复杂的、具有内在逻辑关系的、模型化的管理对象，而且由于它是W3C（互联网联盟）提出的国际标准，因而受到广大软件提供商的支持，易于进行数据交流和开发。 NETCONF协议架构 （1）NetConf采用的是Client Server机制，被管理的网络设备是NetConf的server，网络程序是Client。 （2）NetConf协议承载在TCP/IP协议之上，包括4个子层协议。 安全传输子层：定义用于承载或传输配置、管理数据的网络传输层协议，如SSH, TLS, HTTP... 消息子层：定义配置、管理数据的消息类型, 如RPC（相当于request），RPC reply，notification。 操作子层：定义消息的配置、管理数据的操作类型，如get，set操作。 配置管理数据子层：定义配置管理数据的格式和内容和数据结构，支持Yang语言数据建模语言。 其中安全传输层，消息层，操作层这3层是通过XML文本格式来描述的。 而安全传输子层是借用了已有的各种互联网传输协议协议。 安全传输子层 NETCONF的第一大优势就是其从协议层面就已经规定其传输层必须使用带有安全加密的通信协议， 且借用已有的各种互联网传输协议协议，以及支持其他未来可能会出现的新的传输层协议。如SSH, TLS, SOAP/Http/TLS等。 相比与其它允许明文传输的协议来说其在协议层面就已经对数据安全做了第一道守护。 由于是借用的已有协议，在这里不对它们进行进一步的探讨。 消息子层 NETCONF协议，真正的新标准的部分，是从消息子层开始，并通过XML文本格式的明文进行承载。 NETCONF中定义了三种消息类型，分别是： hello rpc和rpc-reply notification hello消息 仅用于时 netconf-server 和 netconf-client 之间进行交换双方的管理XML中数据的能力。 一般来说，C/S双方互发消息且协商版本成功后，认为netconf会话建立成功。 常用的几种数据管理的能力有： (1) XPath Capability **XPath**为XML路径语言（XML Path Language），它是一种用来定位XML文档中数据位置的语言 该能力表示client是否可以在filter中使用XPath表达式作为过滤条件，来标识一个或一组XML中的数据。 Capability Identifier: urn:ietf:params:netconf:capability:xpath:1.0 (2) Writable-Running Capability 该能力表示server是否支持直接对库中的数据进行修改操作。 Capability Identifier: urn:ietf:params:netconf:capability:writable-running:1.0 (3) Candidate Configuration Capability 该能力表示server是否具有一个candidate数据库，并且可以将candidate数据库中的配置，提交生效并更新到running数据库 Capability Identifier: urn:ietf:params:netconf:capability:candidate:1.0 (４) Rollback-on-Error Capability 该能力表示server在执行client发送的配置数据出错后是否可以进行回滚 Capability Identifier: urn:ietf:params:netconf:capability:rollback-on-error:1.0 (５) Validate Capability 该能力表示server是否能够校验client发送的配置数据是否正确 Capability Identifier: urn:ietf:params:netconf:capability:validate:1.1 (６) Distinct startup Capability 该能力表示server有一个startup数据库，用于保存启动配置 Capability Identifier: urn:ietf:params:netconf:capability:startup:1.0 rpc 请求与 rpc-reply 应答消息 （1） **是由netconf-client发起的，发送到netconf-server的消息。用于client请求server执行某项具体的操作。** 包含一个强制属性”message-id”，这个id是一个单调递增的正整数，同一会话内不能重复。 该id用于和的配对。 （2） 是有netconf-server发送给netconf-client的rpc响应。 不能主动发起，仅能在收到之后回复，切必须携带与收到的rpc相同的message-id。 在定义了两种默认的元素分别是和。 表示未定义响应内容的rpc执行成功， 而表示rpc执行失败。 notification 通知消息 用于netconf-server向netconf-client主动单方向上报消息。 （1）Netconf的通知采用的是订阅发布机制，server仅会向发送过订阅请求的client发送通知。 （2）Netconf的通知是以Stream进行分类的，不同类的Stream以不同的stream-name进行区分。netconf-server默认需要支持的stream-name是”NETCONF”。 操作子层 操作子层定义消息的配置、管理数据的操作类型。 因此，操作层仅针对和消息上，和消息无操作层。 NETCONF协议规定了9种简单的rpc操作，同时也支持用户自定义rpc操作。 （1）：查询状态数据 （2）：查询配置数据 （3）：修改配置数据 数据对象的的子操作有： merge: 合并操作，此操作为默认操作。 replace: 替换操作，如果对象已经存在则替换，不存在则创建。 create: 创建操作，如果对象已经存在，则报错误“data-exists”。 delete: 删除操作，如果对象存在则删除，不存在则报错 “data-missing”。 remove: 删除操作，如果对象存在则删除，不存在则忽略。 （4）：copy配置数据 （5）：删除配置数据 （6）：锁定数据库，在修改、删除数据库时，必须先锁定数据库 （7）：解锁定数据库。 （8）：正常关闭一个会话 （9）：强行关闭一个会话 get 用于查询状态数据。 例如，要获取server支持的能力：urn:ietf:params:netconf:capability:xpath:1.0，则还可以使用filter进行条件查询 代码案例： eth0 eth0 45621 774344 get-config 用于查询配置数据，可以通过 来指定不同的配置数据库。 代码案例： root superuser Charlie Root 1 1 elements appear here... --> edit-config 用于对指定配置数据库的内容进行修改，支持以下几种子操作： merge: 合并操作，此操作为默认操作。 replace: 替换操作，如果对象已经存在则替换，不存在则创建。 create: 创建操作，如果对象已经存在，则报错误“data-exists”。 delete: 删除操作，如果对象存在则删除，不存在则报错 “data-missing”。 remove: 删除操作，如果对象存在则删除，不存在则忽略。 代码案例： Ethernet0/0 1500 192.0.2.4 24 none 0.0.0.0 192.0.2.4 copy-config 将一个库的数据复制到另一个库。 代码案例： https://user:password@example.com/cfg/new.txt delete-config 删除一个数据库。但是库不能被删除。 代码案例： lock 获取指定数据库的锁，当某个client获得了指定数据库的锁之后，在其没有释放该锁之前，其余client均不能获得该数据库的锁，也不能对其进行修改操作。同一client也不能在没有释放锁之前，重复申请锁。 获取锁的主要目的就是避免并发导致数据冲突。 代码案例： unlock 释放指定数据库的锁。client只能释放自己持有的锁，不能释放其它client的锁。 代码案例： close-session 优雅关闭netconf会话，netconf-server将释放该client持有的锁和为其分配的资源，并优雅的关闭与该client链接。所有在之后收到的操作均会被忽略。 kill-session 强制关闭netconf会话。 内容子层 **开放性**、**标准化**的配置、管理数据是整个netconf协议的**精髓**所在。 放体性：体现在netconf协议本身不对内容层的配置和管理数据的**数据结构**做任何的**预先**、**固定化**的**限定**和**规定**。 标准化：体现在对内容层的配置、管理数据的**格式和数据结构的定义**能够进行某种约束，不能以任意的形式存在，否则就**无法**实现不同节点之间进行**互联互通**。 **Yang语言是数据进行建模的一种语言，NetConf使用Yang语言对内容子层的数据进行约束和建模**。 在netconf出现之前，我们所熟知且常用的协议，均采用在协议中**固定**的报文的结构体，并按字节流读取并解析的架构。 为了更好的在字节流中表达更丰富的报文结构，我们采用TLV等方式来定义对象。但这种方式几乎虽然具备了一定的扩展伸缩性，不具备任何扩展性，一旦扩充**新的对象**，或修改对象，就需要变更代码。而如果对一个协议扩展了大量的私有数据，那么首先协议不在标准，其次协议栈的代码几乎是完全重写。 **而netconf的出现可以说直接对上述问题进行了一次”降维“打击，它完全站在了一个更高的维度来解决上述问题**。 其内容层未指定具体的模型结构，而是指定了一套建模语言–yang。也就是说使用yang定义的数据模型，均可以作为netconf的内容层。所以对netconf而言，“扩展”就是不断的增加和修改Yang语言的配置文件而已。而这个配置文件是文本文件，不需要重新编译目标代码，就可以执行的配置、管理数据。 Yang本身是独立于NetConf的数据建模语言，NetConf只是借用该数据建模语言，并提供对其的支持。 "},"ORAN/6.ORAN_yang.html":{"url":"ORAN/6.ORAN_yang.html","title":"6. O-RAN FrontHaul前传接口的网络配置管理与Yang数据建模语言","keywords":"","body":"O-RAN FrontHaul前传接口的网络配置管理与Yang数据建模语言 前言： 程序=数据结构+算法，任何程序基本上都是解决这两个问题。 数据结构是指相互之间存在一种或多种特定关系的数据元素的集合，是计算机存储、组织数据元素的方式。 大多数的编程语言，如C, C++, Java，phython都提供了对数据的描述性语法，用于定义特定数据结构的数据。如C/C++语言的基础数据类型、struct 结构体数据类型、union联合体数据类型、array数组类型类型，并通过这些预定义的数据类型，表达和定义更加复杂的数据类型，如链表、树、堆栈、hash表。 然后，对于程序而言，这些数据结构都是事先定义好的，当这些数据结构发生改变时，相应的数据处理的程序需要重新编译。 这是一种算法与数据结构是一种强绑定关系的编程语言。 有没有一种编程语言，对数据的描述，可以脱离算法程序，可以单纯的定义或表达数据的结构呢？ Yang 数据建模语言，就是这样的一种数据描述性语言， 它通过文本的方式表达和描述数据的数据结构， 通过xml文本的方式来承载对数据结构的表述。 并且能够对Yang建模后的数据结构进行实例化，定义特定的数据类型的数据。 NetConf就是使用Yang语言对内容子层的数据进行约束和建模的。 YANG概述 YANG是最初设计用于为NETCONF协议的内容子层的数据建模。 YANG定义了可用于基于NETCONF的操作（包括配置，状态数据，RPC和通知）的数据层次结构。这允许在NETCONF客户端和服务器之间发送的所有数据的完整描述。当然YANG也可以使用除NETCONF以外的协议。 YANG将数据进行模型化和结构化，它把某一个系统的所有数据组成为一棵树。 树上的每个节点都有一个名称：其值或者一个叶子节点的数值或一组子节点。YANG提供了对节点的清晰简洁的描述，以及这些节点之间的交互。 为了更加有效的组织大型数据，YANG还将整个系统的数据模型，进行了进一步的分解，分解成模块和子模块。 模块可以从其他外部模块导入定义，并可以包含子模块的定义。可以增加层次结构，允许一个模块将数据节点添加到另一个模块中定义的层次结构中。这种增加可以是有条件的，只有在满足某些条件的情况下才会出现新的节点。 **类似通过Python编程语言，可以实现逻辑的编程，通过YANG数据建模语言，可以实现对数据的建模或编程**。 YANG主要功能包括： （1）数据结构建模 对一组相关性的数据的数据结构进行描述。C语言中称为定义数据结构，C++中称为定义类Class。 对数据的约束条件进行描述：比如数据值的范围、数据的默认值等。这些约束可以由客户端或服务器强制执行。 （2）实例化数据 定义数据结构的对应的数据的实例，C语言中称为变量定义，C++中称为对象的实例化。 YANG定义了一组内置的类型，通过内置的基础数据类型可以定义更加复杂的数据类型。 YANG是一个可扩展的语言，允许标准组织，供应商和个人对其进行扩展。 总之， （1）YANG首先是一门数据建模/编程语言 （2）对数据，而不是程序逻辑进行编程 （3）实现代码逻辑与数据描述的分离 YANG语言的主要语法要素 模块和子模块 这是组织大型数据的工程化手段。 YANG数据模型在模块Module中定义，类似Python的模块。一个模块包含相关数据模型定义的集合。 一个模块包含三种类型的语句： （1）模块头(module header)语句：模块头部语句描述模块并提供关于模块本身的信息， （2）“修订”(revision)语句：提供关于模块历史的信息 （3）定义(definition)语句：定义语句是定义数据模型的模块的主体。 可以通过import和include包含其他的子模块。 树形节点的类型 YANG定义了数据建模的四种主要类型的数据节点 叶子节点(Leaf Nodes) 叶子列表节点(Leaf-List Nodes) 容器节点(Container Nodes)=》目录 列表节点(List Nodes)=》数组 （1）叶节点(Leaf Nodes) 叶子节点包含简单的数据，如整数或字符串。 它只有一个特定类型的值，没有子节点。 YANG 例子： leaf host-name { type string; description \"Hostname for this system.\"; } XML编码示例： my.example.com （2）叶列表节点(Leaf-List Nodes) 叶列表定义了特定类型的值序列，即可以利用该数据类型定义一个数组。 YANG例如： leaf-list domain-search { type string; description \"List of domain names to search.\"; } XML编码示例（数组）： high.example.com low.example.com everywhere.example.com （3）容器节点(Container Nodes) 一个容器用于分组子树中的相关节点。 一个容器只有子节点，没有值。 容器可以包含任何类型、任何数量的子节点（叶子，列表，容器，叶子列表，动作和通知）。 YANG例如： container system { container login { leaf message { type string; description \"Message given at start of login session.\"; } } } XML编码示例： Good morning （4）列表节点(List Nodes) 列表定义了一系列列表条目。 每个条目就像一个容器，如果它定义了任何关键的叶子，它就被其关键叶子的值唯一标识。 列表可以定义多个关键叶子，并且可以包含任何类型的任何数量的子节点（包括树叶，列表，容器等）。 YANG 例如： list user { key \"name\"; leaf name { type string; } leaf full-name { type string; } leaf class { type string; } } XML编码示例： glocks Goldie Locks class1 snowey Snow White class2 rzell Rapun Zell class3 综合代码案例：这些语句被组合来定义模块。 // Contents of \"example-system.yang\" module example-system { yang-version 1.1; namespace \"urn:example:system\"; prefix \"sys\"; organization \"Example Inc.\"; contact \"joe@example.com\"; description \"The module for entities implementing the Example system.\"; revision 2007-06-09 { description \"Initial revision.\"; } container system { leaf host-name { type string; description \"Hostname for this system.\"; } leaf-list domain-search { type string; description \"List of domain names to search.\"; } container login { leaf message { type string; description \"Message given at start of login session.\"; } list user { key \"name\"; leaf name { type string; } leaf full-name { type string; } leaf class { type string; } } } } } 数据的配置和状态属性(Configuration and State Data) YANG可以根据“config”语句为状态数据和配置数据建模。实际上是指定数据的读写属性。 当一个节点被标记为“config false”时，其子层被标记为状态数据。为只读数据。 如果标记为“config true”，则其子层被标记为配置数据。 在这个例子中，为每个接口定义了两个叶子，一个配置的速度和一个观察到的速度。 list interface { key \"name\"; leaf name { type string; } leaf speed { type enumeration { enum 10m; enum 100m; enum auto; } config true; } leaf observed-speed { type uint32; config false; } } 内置的基本数据类型 类似于大多数编程语言，YANG有一套内置的类型，由于网络管理的特殊要求，有一些不同之处。 名称 描述 binary 任何二进制数据 bits 一组比特(bits)或标志(flags) boolean \"true\" 或 \"false\" decimal64 64位有符号十进制数字 empty 一个叶子，没有任何值 enumeration 枚举的一组字符串之一 identityref 对抽象身份的引用 int8 8位有符号整数 int16 16位有符号整数 int32 32位有符号整数 int64 64位有符号整数 leafref 对叶子实例的引用 string 一个字符串 uint8 8位无符号整数 uint16 16位无符号整数 uint32 32位无符号整数 uint64 64位无符号整数 union 成员类型的选择 下面是原始内置类型总结表 +---------------------+-------------------------------------+ | Name | Description | +---------------------+-------------------------------------+ | binary | Any binary data | | bits | A set of bits or flags | | boolean | \"true\" or \"false\" | | decimal64 | 64-bit signed decimal number | | empty | A leaf that does not have any value | | enumeration | One of an enumerated set of strings | | identityref | A reference to an abstract identity | | instance-identifier | A reference to a data tree node | | int8 | 8-bit signed integer | | int16 | 16-bit signed integer | | int32 | 32-bit signed integer | | int64 | 64-bit signed integer | | leafref | A reference to a leaf instance | | string | A character string | | uint8 | 8-bit unsigned integer | | uint16 | 16-bit unsigned integer | | uint32 | 32-bit unsigned integer | | uint64 | 64-bit unsigned integer | | union | Choice of member types | +---------------------+-------------------------------------+ 派生类型（typedef）(Derived Types (typedef)) YANG可以使用“typedef”语句从基本类型定义派生类型。 基本类型可以是内置类型或派生类型，允许派生类型的层次结构。 派生类型可以用作“类型”语句的参数。 YANG示例： typedef percent { type uint8 { range \"0 .. 100\"; } } leaf completed { type percent; } XML编码示例： 20 可重复使用的节点组（分组）(Reusable Node Groups (grouping)) 可以使用 “grouping” 语句将多个子节点数据描述，组合成一个综合的数据描述，有点类似c语言的宏定义#define，使用时直接被宏替换掉。 并使用 “uses” 语句来使用该组合后的数据描述，有点类似其他编程语言的“函数调用” YANG示例: grouping target { leaf address { type inet:ip-address; description \"Target IP address.\"; } leaf port { type inet:port-number; description \"Target port number.\"; } } container peer { container destination { uses target; } } XML编码示例： 2001:db8::2 830 分组可以根据使用情况进行重新定义或细化，从而允许某些语句被覆盖。 类似c语言的宏定义#define。 在这个例子中，描述被细化： container connection { container source { uses target { refine \"address\" { description \"Source IP address.\"; } refine \"port\" { description \"Source port number.\"; } } } container destination { uses target { refine \"address\" { description \"Destination IP address.\"; } refine \"port\" { description \"Destination port number.\"; } } } } 选择(Choices)： YANG允许数据模型使用 “choice” 和“case”语句将不兼容的节点分隔为不同的选项。类似与C语言的Union数据类型。 “choice”语句包含一组“case”语句，用于定义不能一起出现的模式节点集合。 每个“case”可能包含多个节点，但每个节点可能只出现在“choice”下的一个“case”中。 choice和case节点仅出现在模式树(schema tree)中，而不出现在数据树中。 概念模式之外不需要额外的层次结构。 一个case的存在是由一个或多个节点的存在表示。 由于只有一个选择的情况在任何时候都是有效的，所以当在数据树中创建一个节点时，所有其他情况下的所有节点都被隐式删除。 服务器处理约束的执行，防止配置中存在不兼容。 YANG示例： container food { choice snack { case sports-arena { leaf pretzel { type empty; } leaf beer { type empty; } } case late-night { leaf chocolate { type enumeration { enum dark; enum milk; enum first-available; } } } } } XML编码示例： 扩展数据模型（扩充）(Extending Data Models (augment)) YANG允许模块将其他节点插入数据模型，包括当前模块（及其子模块）和外部模块。 例如，这对于供应商以可互操作的方式向标准数据模型添加供应商特定的参数非常有用。 “augment” 语句定义插入新节点的数据模型层次结构中的位置，“when”语句定义新节点有效时的条件。 当服务器实现一个包含“augment”语句的模块时，这意味着扩充模块的服务器实现包含附加节点。 YANG示例： augment /system/login/user { when \"class != 'wheel'\"; leaf uid { type uint16 { range \"1000 .. 30000\"; } } } 这个例子定义了一个“uid”节点，只有当用户的“class”不是“wheel”时才有效。 如果模块扩充另一个模块，则添加到编码中的XML元素位于扩充模块的命名空间中。 例如，如果上面的扩充是在一个前缀为“other”的模块中，那么XML将如下所示： XML编码示例： alicew Alice N. Wonderland drop-out 1024 “操作”定义 YANG允许定义的操作。 使用YANG数据定义语句对操作名称，输入参数和输出参数进行建模。 模块顶层的操作用“rpc”语句定义。 操作也可以绑定到容器或列表数据节点。 这些操作用“操作”语句来定义。 YANG顶层操作示例： rpc activate-software-image { input { leaf image-name { type string; } } output { leaf status { type string; } } } NETCONF XML示例： example-fw-2.3 The image example-fw-2.3 is being installed. YANG绑定到列表数据节点的操作示例： list interface { key \"name\"; leaf name { type string; } action ping { input { leaf destination { type inet:ip-address; } } output { leaf packet-loss { type uint8; } } } } NETCONF XML示例: eth1 192.0.2.1 60 通知定义 YANG允许定义通知。 YANG数据定义语句用于模拟通知的内容。 YANG示例： notification link-failure { description \"A link failure has been detected.\"; leaf if-name { type leafref { path \"/interface/name\"; } } leaf if-admin-status { type admin-status; } leaf if-oper-status { type oper-status; } } NETCONF XML示例： 2007-09-01T10:00:00Z so-1/2/3.0 up down YANG 1.1 数据建模语言 "},"ORAN/7.ORAN_nFAPI.html":{"url":"ORAN/7.ORAN_nFAPI.html","title":"7. nFAPI接口","keywords":"","body":"L2与L1-High的接口：nFAPI ORAN专题系列-24：5G nFAPI接口 - 中文规范-1- 概述、总体框架 ORAN专题系列-25：5G nFAPI接口 - 中文规范-2- 消息交互流程、物理层与MAC层同步原理 ORAN专题系列-26：5G nFAPI接口 - 中文规范-3- 协议栈、消息格式 ORAN专题系列-27：5G FAPI接口 - 中文规范-1- 概述、总体架构 FAPI专题-5：5G nFAPI接口 - 中文规范-4-VNF与PHY之间的时隙定时管理 FAPI专题-6：5G FAPI接口 - 中文规范-2- 主要流程 "},"ORAN/8.ORAN_eCPRI.html":{"url":"ORAN/8.ORAN_eCPRI.html","title":"8. eCPRI","keywords":"","body":"L1-High与L1-Low的接口：eCPRI [4G&5G专题-9]：前传接口 CPRI与OBSAI的那些事第9章. OBSAI [4G&5G专题-10]：前传接口 eCPRI协议的那些事 "},"CcodeSummary/":{"url":"CcodeSummary/","title":"C/C++","keywords":"","body":"C/C++ "},"CcodeSummary/CPlus/":{"url":"CcodeSummary/CPlus/","title":"C++","keywords":"","body":"C++ "},"CcodeSummary/CPlus/1.cplus_overview-00.html":{"url":"CcodeSummary/CPlus/1.cplus_overview-00.html","title":"C++ 思维导图-01","keywords":"","body":"C++ note 思维 【C++】笔记总结—思维导图（超详细！！！） "},"CcodeSummary/CPlus/2.cplus_overview-01.html":{"url":"CcodeSummary/CPlus/2.cplus_overview-01.html","title":"C++ 思维导图-02","keywords":"","body":"C++ 系列知识详解 [C++ 系列] 90. 超详解C++思维导图 [C++系列] - Ypuyu "},"CcodeSummary/CPlus/3.cplus_overview-02.html":{"url":"CcodeSummary/CPlus/3.cplus_overview-02.html","title":"C++ 思维导图-03","keywords":"","body":"c++ 实用汇总 《C++ Primer》第十二章 类 思维导图 effective c++ 思维导图 类的定义和声明 隐含的this指针 类作用域 类作用域中名字查找 类-构造函数 类-友元 类-static类成员 "},"CcodeSummary/CSkillSummary/":{"url":"CcodeSummary/CSkillSummary/","title":"C技巧汇总","keywords":"","body":"C语言技巧汇总 "},"CcodeSummary/CSkillSummary/1.IPC.html":{"url":"CcodeSummary/CSkillSummary/1.IPC.html","title":"1. 进程间通信","keywords":"","body":"进程间通信的方式 -- 信号、管道、消息队列、共享内存 多进程 首先，先来讲一下fork之后，发生了什么事情。 由fork创建的新进程被称为子进程（child process）。该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程 id。将子进程id返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程id。对子进程来说，之所以fork返回0给它，是因为它随时可以调用getpid()来获取自己的pid；也可以调用getppid()来获取父进程的id。(进程id 0总是由交换进程使用，所以一个子进程的进程id不可能为0 )。 fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。 可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别作不同的工作，也就是分岔了。这也是fork为什么叫fork的原因 至于那一个最先运行，可能与操作系统（调度算法）有关，而且这个问题在实际应用中并不重要，如果需要父子进程协同，可以通过原语的办法解决。 常见的通信方式 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 信号 信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 Linux提供了几十种信号，分别代表着不同的意义。信号之间依靠他们的值来区分，但是通常在程序中使用信号的名字来表示一个信号。在Linux系统中，这些信号和以他们的名称命名的常量被定义在/usr/includebitssignum.h文件中。通常程序中直接包含就好。 信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式，信号可以在用户空间进程和内核之间直接交互。内核也可以利用信号来通知用户空间的进程来通知用户空间发生了哪些系统事件。信号事件有两个来源： 1）硬件来源，例如按下了cltr+C，通常产生中断信号 sigint 2）软件来源，例如使用系统调用或者命令发出信号。最常用的发送信号的系统函数是kill,raise,setitimer,sigation,sigqueue函数。软件来源还包括一些非法运算等操作。 一旦有信号产生，用户进程对信号产生的相应有三种方式： 1）执行默认操作，linux对每种信号都规定了默认操作。 2）捕捉信号，定义信号处理函数，当信号发生时，执行相应的处理函数。 3）忽略信号，当不希望接收到的信号对进程的执行产生影响，而让进程继续执行时，可以忽略该信号，即不对信号进程作任何处理。 有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，这是为了使系统管理员能在任何时候中断或结束某一特定的进程。 上图表示了Linux中常见的命令 信号发送： 信号发送的关键使得系统知道向哪个进程发送信号以及发送什么信号。下面是信号操作中常用的函数： 例子：创建子进程，为了使子进程不在父进程发出信号前结束，子进程中使用 raise 函数发送 sigstop 信号，使自己暂停；父进程使用信号操作的kill函数，向子进程发送 sigkill 信号，子进程收到此信号，结束子进程。 信号处理 当某个信号被发送到一个正在运行的进程时，该进程即对次特定的信号注册相应的信号处理函数，以完成所需处理。设置信号处理方式的是 signal 函数，在程序正常结束前，在应用 signal 函数恢复系统对信号的 默认处理方式。 信号阻塞 有时候既不希望进程在接收到信号时立刻中断进程的执行，也不希望此信号完全被忽略掉，而是希望延迟一段时间再去调用信号处理函数，这个时候就需要信号阻塞来完成。 例子：主程序阻塞了cltr+c 的 sigint信号。用 sigpromask 将 sigint 假如阻塞信号集合。 管道 管道允许在进程之间按先进先出的方式传送数据，是进程间通信的一种常见方式。 管道是Linux 支持的最初Unix IPC形式之一，具有以下特点： 1) 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道； 2) 匿名管道只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）； 3) 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。 管道分为pipe（无名管道）和fifo（命名管道）两种，除了建立、打开、删除的方式不同外，这两种管道几乎是一样的。他们都是通过内核缓冲区实现数据传输。 pipe用于相关进程之间的通信，例如父进程和子进程，它通过pipe()系统调用来创建并打开，当最后一个使用它的进程关闭对他的引用时，pipe将自动撤销。 FIFO即命名管道，在磁盘上有对应的节点，但没有数据块——换言之，只是拥有一个名字和相应的访问权限，通过mknode()系统调用或者mkfifo()函数来建立的。一旦建立，任何进程都可以通过文件名将其打开和进行读写，而不局限于父子进程，当然前提是进程对FIFO有适当的访问权。当不再被进程使用时，FIFO在内存中释放，但磁盘节点仍然存在。 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。 无名管道 pipe的例子：父进程创建管道，并在管道中写入数据，而子进程从管道读出数据 命名管道 和无名管道的主要区别在于，命名管道有一个名字，命名管道的名字对应于一个磁盘索引节点，有了这个文件名，任何进程有相应的权限都可以对它进行访问。 而无名管道却不同，进程只能访问自己或祖先创建的管道，而不能访任意访问已经存在的管道——因为没有名字。 Linux中通过系统调用 mknod() 或 makefifo() 来创建一个命名管道。最简单的方式是通过直接使用shell mkfifo myfifo 等价于 mknod myfifo p 以上命令在当前目录下创建了一个名为 myfifo 的命名管道。用 ls -p 命令查看文件的类型时，可以看到命名管道对应的文件名后有一条竖线 \"|\"，表示该文件不是普通文件而是命名管道。 使用 open() 函数通过文件名可以打开已经创建的命名管道，而无名管道不能由 open 来打开。当一个命名管道不再被任何进程打开时，它没有消失，还可以再次被打开，就像打开一个磁盘文件一样。 可以用删除普通文件的方法将其删除，实际删除的事磁盘上对应的节点信息。 例子：用命名管道实现聊天程序，一个张三端，一个李四端。两个程序都建立两个命名管道，fifo1,fifo2,张三写fifo1，李四读fifo1；李四写fifo2，张三读fifo2。 用 select 把，管道描述符和 stdin 假如集合，用 select 进行阻塞，如果有 i/o 的时候唤醒进程。（粉红色部分为select部分，黄色部分为命名管道部分） 在linux系统中，除了用pipe系统调用建立管道外，还可以使用C函数库中管道函数popen函数来建立管道，使用pclose关闭管道。 例子：设计一个程序用popen创建管道，实现 ls -l |grep main.c 的功能 分析：先用popen函数创建一个读管道，调用fread函数将ls -l的结果存入buf变量，用printf函数输出内容，用pclose关闭读管道； 接着用popen函数创建一个写管道，调用fprintf函数将buf的内容写入管道，运行grep命令。 popen的函数原型： FILE* popen(const char* command,const char* type); 参数说明： command 是子进程要执行的命令， type 表示管道的类型，r表示读管道，w代表写管道。 如果成功返回管道文件的指针，否则返回NULL。 使用popen函数读写管道，实际上也是调用pipe函数调用建立一个管道，再调用fork函数建立子进程，接着会建立一个shell 环境，并在这个shell环境中执行参数所指定的进程。 消息队列 消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。 消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。 可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。 消息队列的常用函数如下表： 进程间通过消息队列通信，主要是：创建或打开消息队列，添加消息，读取消息和控制消息队列。 例子：用函数 msget 创建消息队列，调用 msgsnd 函数，把输入的字符串添加到消息队列中，然后调用 msgrcv 函数，读取消息队列中的消息并打印输出，最后再调用 msgctl 函数，删除系统内核中的消息队列。（黄色部分是消息队列相关的关键代码，粉色部分是读取stdin的关键代码） 共享内存 共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。 采用共享内存进行通信的一个主要好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，则需要再内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。 一般而言，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时在重新建立共享内存区域；而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件，因此，采用共享内存的通信方式效率非常高。 共享内存有两种实现方式： 1、内存映射 2、共享内存机制 内存映射 内存映射 memory map机制使进程之间通过映射同一个普通文件实现共享内存，通过 mmap() 系统调用实现。普通文件被映射到进程地址空间后，进程可以 像访问普通内存一样对文件进行访问，不必再调用read/write等文件操作函数。 例子：创建子进程，父子进程通过匿名映射实现共享内存。 分析：主程序中先调用 mmap 映射内存，然后再调用 fork 函数创建进程。那么在调用 fork 函数之后，子进程继承父进程匿名映射后的地址空间，同样也继承 mmap 函数的返回地址，这样，父子进程就可以通过映射区域进行通信了。 UNIX System V共享内存机制 IPC的共享内存指的是把所有的共享数据放在共享内存区域（IPC shared memory region），任何想要访问该数据的进程都必须在本进程的地址空间新增一块内存区域，用来映射存放共享数据的物理内存页面。 和前面的 mmap 系统调用通过映射一个普通文件实现共享内存不同，UNIX system V共享内存是通过映射特殊文件系统 shm 中的文件实现进程间的共享内存通信。 例子：设计两个程序，通过unix system v共享内存机制，一个程序写入共享区域，另一个程序读取共享区域。 分析：一个程序调用 fotk 函数产生标准的key，接着调用 shmget 函数，获取共享内存区域的id，调用 shmat 函数，映射内存，循环计算年龄，另一个程序读取共享内存。 （fotk函数在消息队列部分已经用过了，根据pathname指定的文件（或目录）名称，以及proj参数指定的数字，ftok函数为IPC对象生成一个唯一性的键值。） key_t ftok(char* pathname,char proj) "},"CcodeSummary/CDesignMode/":{"url":"CcodeSummary/CDesignMode/","title":"C设计模式","keywords":"","body":"C设计模式 【摘要】 前言：软件编写模式是开发过程中的重要经验总结。灵活运用设计模式，一方面利于我们编写高质量的代码，另一方面也方便我们对代码进行维护。 本资料合集共十章--简单讲解设计模式的思路，在嵌入式中的应用和样例代码入手，特别是注意设计模式在linux内核和实际开发中的应用，总结出真正在C语言和嵌入式开发中有生命力的少数几个模式。C语言实现设计模式的几个利器有结构体，函数指针，利用数组实现多态。 章节介绍： 设计模式C语言-第一章 开篇介绍 设计模式C语言-第二章——状态机模式 模式介绍：状态机模式 状态（state）模式是C语言实现相当常用的模式，也是能够在C语言展现出来的最显性的模式之一。在面向对象里，状态模式允许一个对象在内部状态改变的时候改变其行为。 设计模式C语言-第三章——责任链模式 模式介绍：责任链模式 责任链将需要触发的对象组成一条链，发送者将请求发给链的第一个接收者，并且沿着这条链传递，直到有一个对象来处理它或者直到最后也没有对象处理而留在链末尾端。 设计模式C语言-第四章——观察者模式 模式介绍：观察者模式 观察者模式定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。在这里，发生改变的对象称之为观察目标，而被通知的对象称之为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，所以么可以根据需要增加和删除观察者，使得系统更易于扩展。 设计模式C语言-第五章——命令模式 命令模式介绍如下： 向对象发送一个请求，但是并不知道该请求的具体接收者是谁，具体的处理过程是如何的，只知道在程序运行中指定具体的请求接收者即可，对于这样将请求封装成对象的我们称之为命令模式。所以命令模式将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。同时命令模式支 持可撤销的操作。 设计模式C语言-第六章——适配及系列模式 在《设计模式》中提出的23种模式，其中适配器模式(Adapter)，装饰者模式(Decorator)，代理模式(Proxy)都属于原始功能到目标功能之间的桥梁。 在面向对象里的设计里，这3种由于类的继承等面向对象特性，有比较明显的不同。在C语言里这些区别明显减弱，而且在实际的开发中，也没有这么多约束，所以统称为适配系列模式。 设计模式C语言-第七章——建造者模式 模式介绍：建造者模式 建造者模式将复杂产品的构建过程封装分解在不同的方法中，使得创建过程非常清晰。它隔离了复杂产品 对象的创建和使用，使得相同的创建过程能够创建不同的产品。若几个 产品之间存在较大的差异，则不适用建造者模式 设计模式C语言-第八章——外观模式 外观模式也叫门面模式 外观模式就是提供一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。如下图，是使用外观模式后将子系统的使用变得更加简单。 设计模式C语言-第九章——访问者模式 访问者模式介绍： 把对象数据和操作分离，使操作可以独立演化。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式是适用于那些数据结构比较稳定的模式。这个算是在C里面退化的不是那么厉害的一种模式思想, 或者说这种方法和C实现天然结合而不成为模式。因为C里面本来就很少将数据和访问方法封装在一起，数据的组织形式是数据结构的范畴，访问函数是代码流程设计的范畴。 设计模式C语言-第十章——非典型模式 上一章为止，C语言里显性和隐性的设计模式都已经介绍完了。 非典型模式章节开始介绍23种设计模式里在C语言退化的，不适用的。这些模式在使用中很难想到其实也是一种设计模式，代码的实现也没有什么特点。开发人员在设计时并不需要特意考虑这些模式，随遇而安即可。 "},"CcodeSummary/CDesignMode/1.Overview.html":{"url":"CcodeSummary/CDesignMode/1.Overview.html","title":"1. 概览","keywords":"","body":"概览 【摘要】 软件编写模式是开发过程中的重要经验总结。灵活运用设计模式，一方面利于我们编写高质量的代码，另一方面也方便我们对代码进行维护。 软件编写模式是开发过程中的重要经验总结。灵活运用设计模式，一方面利于我们编写高质量的代码，另一方面也方便我们对代码进行维护。 设计模式最开始是针对面向对象语言提出的。经典的书如《设计模式：可复用面向对象软件的基础》,《java与模式》。《设计模式》的作者俗称 ”GOF”, gang of four，书中从面向对象的设计中精选出23个设计模式，这个也成了后来设计模式的范例。 C语言设计模式的书非常少，目前没有看到合适的。有一本《C嵌入式编程设计模式》，作者douglass。书一共6章，里面没有太多高含金量的内容。书的主要问题在于没有真正把设计模式应用到C，而是把一些基本的嵌入式开发注意点包装成模式，中断算一种设计模式，轮询算一种设计模式，互斥算一种模式。照这个套路，C函数指针使用肯定也算一种模式，强制类型转换肯定也得算。我觉得是为了出书而滥造模式。 本专题尝试简单讲解设计模式的思路，在嵌入式中的应用和样例代码入手，特别是注意设计模式在linux内核和实际开发中的应用，总结出真正在C语言和嵌入式开发中有生命力的少数几个模式。 C语言实现设计模式的几个利器有结构体，函数指针，利用数组实现多态。 本专题讲解模式会按照如下格式： 模式的介绍 模式的应用场景 样例代码 模式总结 样例代码全部以C代码实现，可能会穿插讲解java样例以方便对比为什么C实现模式演化成这个样子以及和面向对象语言的差异。 C语言应用设计模式的误区 在C语言开发中应用设计模式有几种现象，分析如下 用C模拟面向对象 用C模拟面向对象，用结构体模拟类，用结构体包含看作继承。这种做法在特定需要的场合少量使用尚可，但是如果为了模拟面向对象的特性就南辕北辙了。 用很多特定的宏来将C在形式上封装为C++ 用C模仿面向对象和设计模式有另外一种流派，就是用很多特定的宏来封装。我非常反对这种用法，因为基本上对于程序员而言，已经对C语言的阅读和书写造成了严重的干扰，不能为了面向对象而面向对象，C语言自然有其简洁高效的一面。 盲目追求设计模式 随着设计模式的思想的普及，很多设计师对设计模式盲目崇拜和过分追求，为了用模式而用模式，削足适履。对于嵌入式开发常用的C语言而言，少了很多面向对象的特点，经典的23个设计模式肯定不会都适用，而且在实际工作中，其实也不会为了模式而模式。而且从技术上讲23个设计模式当时是围绕面向对象提出的，有的模式偏向于逻辑，那么可以被C借鉴，有的是为了解决面向对象本身的集成，关联等问题，那就没有必要借鉴。 设计模式的分类 设计模式如下分为创建型模式，结构型模式，行为型模式。 创建型模式 ​ 1、抽象工厂模式(Abstract Factory) ​ 2、建造者模式(Builder) ​ 3、工厂方法模式(Factory Method) ​ 4、原型模式(Prototype) ​ 5、单例模式(Singleton) 结构型模式 ​ 1、适配器模式(Adapter) ​ 2、桥接模式(Bridge) ​ 3、组合模式(Composite) ​ 4、装饰者模式(Decorator) ​ 5、外观模式(Facade) ​ 6、享元模式(Flyweight) ​ 7、代理模式(Proxy) 行为型模式 ​ 1、职责链模式(Chain of Responsibility) ​ 2、命令模式(Command) ​ 3、解释器模式(Interpreter) ​ 4、迭代器模式(Iterator) ​ 5、中介者模式(Mediator) ​ 6、备忘录模式(Memento) ​ 7、观察者模式(Observer) ​ 8、状态模式(State) ​ 9、策略模式(Strategy) ​ 10、模板方法模式(Template Method) ​ 11、访问者模式(Visitor) "},"CcodeSummary/CDesignMode/2.StateMechine.html":{"url":"CcodeSummary/CDesignMode/2.StateMechine.html","title":"2. 状态机模式","keywords":"","body":"状态机模式 【摘要】 状态（state）模式是C语言实现相当常用的模式，也是能够在C语言下 体现出来的最显性的模式之一。在面向对象里，状态模式允许一个对象在内部状态改变的时候改变其行为。 模式介绍 状态（state）模式是C语言实现相当常用的模式，也是能够在C语言现出来的最显性的模式之一。在面向对象里，状态模式允许一个对象在内部状态改变的时候改变其行为。 状态用法很多，最常见的是状态机，分为无限状态机和有限状态机。 有限状态机 finite-state machine， FSM， 输入集合和输出集合都是有限的，并只有有限数目的状态。 一般说到状态机即是对有限状态机的简称。 无限状态机 infinite-state machine，ISM ，输入和输出集合无线，状态数目无限的状态机。 在C语言里，状态模式有且仅有一种经典用法，就是有限状态机（FSM）的实现。实现的方式极为突出明显，大部分情况都能直接照搬框架。 状态机最常见的使用场景是实现协议。通常协议会有几个核心状态机描述。 有限状态机 状态机示例1 有一个灯，按下开按钮，就会开灯，按下关按钮就会关灯。这就是一个很典型的简单的有限状态机。简单的描述有2个状态，关灯[STATE_OFF]，亮 [STATE_LIGHT_ON] 。有两个事件，开和关按钮。这两个事件促使状态机间的转换。 状态机示例2 有一个灯，按下开按钮，就会开灯，按下关按钮就会关灯。和一般等不同的是，两次开之间的灯的明暗不一样。也就是说，第一次开的时候，是高亮，关灯后，再开是低亮，下次再开是高亮，循环往复。 这就是一个很典型的简单的有限状态机。简单的描述有3个状态，关灯 [STATE_OFF]，高亮[STATE_HIGH_LIGHT]，低亮 [STATE_LOW_LIGHT]。 简单状态机模式实现 以状态机示 例1 为目标，如果用 if/switch/case 来，就没有什么设计和模式的意义，那只是最普通的流程开发技能。以下是简单状态机模式实现，适用于转移条件单一，对结果很确定的状态机。 #define STATE_OFF 0 #define STATE_LIGHT_ON 1 #define STATE_MAX 2 #define EVETN_BTN_OFF #define EVETN_BTN_ON #define EVETN_MAX int light_fsm_simple_table[STATE_MAX][EVETN_MAX] = { [STATE_OFF][EVETN_BTN_OFF] = STATE_OFF, [STATE_OFF][EVETN_BTN_ON] = STATE_LIGHT_ON, [STATE_LIGHT_ON][EVETN_BTN_OFF] = STATE_OFF, [STATE_LIGHT_ON][EVETN_BTN_ON] = STATE_LIGHT_ON }; int light_fsm_event(int cur_stat, int event) { int next_state; next_state = light_fsm_simple_table[cur_stat][event]; return next_state; } int main() { int light_state = STATE_OFF; int eve1 = EVETN_BTN_OFF; int eve2 = EVETN_BTN_ON; light_state = light_fsm_event(light_state, eve1); printf(\"now light state is %d\\n\", light_state); light_state = light_fsm_event(light_state, eve2); printf(\"now light state is %d\\n\", light_state); } 以上代码有几个要点 状态转移数组。由于简单模式某种状态下发生某事件的结果是确定的，所以数组的值就是下一个状态。 需要一个状态处理的封装函数 light_fsm_event。里面除了转移状态，可以增加扩展处理。不然简单模式应用就很局限。比如可以在 light_fsm_event 里面加入 if(next_state == STATE_LIGHT_ON) { printf(\"light is on\"); } 普通状态机模式实现 大型一点的项目，比如复杂协议的实现，一个状态转移到下一个状态的情况是比较复杂的，无法用当前状态和事件简单确定，所以一般需要函数。 以下代码实现了状态机 示例二，为样例代码，未运行实验过。 #define STATE_DEPEND 4 #define STATE_OFF 0 #define STATE_HIGH_LIGHT 1 #define STATE_LOW_LIGHT 2 #define STATE_MAX 3 #define EVETN_BTN_OFF #define EVETN_BTN_ON #define EVETN_MAX int last_state = STATE_LOW_LIGHT; int last_light_state = STATE_LOW_LIGHT; struct { int (*func) (); int next_state; } light_fsm [STATE_MAX][EVETN_MAX] = { //STATE_OFF { { lfsm_ignore, STATE_MAX }, /*EVETN_BTN_OFF*/ { lfsm_btn_on, STATE_DEPEND }, /*EVETN_BTN_ON*/ } //STATE_HIGH_LIGHT { { lfsm_btn_off, STATE_OFF }, /*EVETN_BTN_OFF*/ { lfsm_ignore, STATE_MAX }, /*EVETN_BTN_ON*/ } //STATE_LOW_LIGHT { { lfsm_btn_off, STATE_OFF }, /*EVETN_BTN_OFF*/ { lfsm_ignore, STATE_MAX }, /*EVETN_BTN_ON*/ } } int lfsm_ignore(int cur_stat, int event) { printf(\"invalid state or event\\n\"); return 0; } int lfsm_btn_on(int cur_stat, int event) { if(last_light_state == STATE_HIGH_LIGHT) { return STATE_LOW_LIGHT; } else if(last_light_state == STATE_LOW_LIGHT) { return STATE_HIGH_LIGHT; } else { printf(\"invalid state\\n\"); return STATE_MAX; } } int lfsm_btn_off(int cur_stat, int event) { last_light_state = cur_stat; return 0; } int light_change_state(int cur_stat, int next_state,int event) { //if light on has special handling if(next_state = STATE_HIGH_LIGHT) { printf(\"rejoice, now bright light\\n\") }; //other state change related handlings, maybe use current state and next state, or event type last_state = cur_stat; cur_stat = next_state; return 0; } int light_event_happen(int event) { //if light on has special handling if(event = EVETN_BTN_OFF) { printf(\"someone turn off light\\n\"); } //other event type related handlings return 0; } int light_fsm_event(int cur_stat, int event) { int next_state, next_state_tmp; next_state_tmp = *(light_fsm[cur_stat][event].func); if(next_state_tmp == STATE_MAX) { printf(\"fsm error\\n\"); return -1; } if(light_fsm[cur_stat][event].next_state == STATE_DEPEND) { next_state = next_state_tmp; } else { next_state = light_fsm[cur_stat][event].next_state; } light_change_state(next_state, cur_stat, event); light_event_happen(event); } int main() { int light_state = STATE_OFF; light_fsm_event(light_state, EVETN_BTN_OFF); light_fsm_event(light_state, EVETN_BTN_ON); light_fsm_event(light_state, EVETN_BTN_OFF); light_fsm_event(light_state, EVETN_BTN_ON); } 普通模式的状态机的几个关键点 状态机数组由状态事件处理函数 + 下一个状态数组代替简单模式的下一个状态的数组 由于在特定模式特定事件发生时，有的情况不能确定下一个状态的跳转，有的情况可以。所以下一状态有个特殊值为 STATE_DEPEND。如果遇到这个值，就从状态变化函数里获得下一个状态。否则按照状态机数组设定的状态。 设定一个状态 STATE_MAX 用来表示错误事件，加上一个 lfsm_ignore 函数来处理这种情况。比如本例中，设定 EVETN_BTN_ON 不可能在开灯的时候发生。 状态机里除了状态机数字函数执行，有两类通用的函数，不参与主要的状态机运行，但是对状态机有影响。一类和特定的状态或状态转移有关，另外一类是和特定的事件有关。在样例代码里分别以 light_change_state 和 light_event_happen 来表示。 一般情况下，有一个全局变量保存当前状态和上一个状态。 面向对象语言实现状态机通常是一个状态的抽象父类，每个状态有一个子类和一个实例。C语言里状态转移表的函数指针是通过状态子类的成员函数实现。其他的写法思路比较接近。 复杂状态机模式实现 最常见的复杂状态机是为了实现网络协议。比如 OSPF，可以参见我写的另外一篇文章 ZEBRA中FSM编写总结.doc 模式实现总结 项目开发里最常见的使用为普通状态机，网络协议使用的复杂状态机也是在普通状态机上添加一些特性而来，基本特征是非常类似的。 C语言实现状态机的模式是非常固定的。状态转移表和核心的状态转移函数是核心。普通状态机的几个要素，不管在初始设计中有没有使用到，建议都写上。 "},"CcodeSummary/CDesignMode/3.Chain_of_Responsibility.html":{"url":"CcodeSummary/CDesignMode/3.Chain_of_Responsibility.html","title":"3. 责任链模式","keywords":"","body":"责任链模式 "},"CcodeSummary/CDesignMode/4.Observer.html":{"url":"CcodeSummary/CDesignMode/4.Observer.html","title":"4. 观察者模式","keywords":"","body":"观察者模式 "},"CcodeSummary/CDesignMode/5.Command.html":{"url":"CcodeSummary/CDesignMode/5.Command.html","title":"5. 命令模式","keywords":"","body":"命令模式 "},"CcodeSummary/CDesignMode/6.Adapter.html":{"url":"CcodeSummary/CDesignMode/6.Adapter.html","title":"6. 适配及系列模式","keywords":"","body":"适配及系列模式 "},"CcodeSummary/CDesignMode/7.Builder.html":{"url":"CcodeSummary/CDesignMode/7.Builder.html","title":"7. 建造者模式","keywords":"","body":"建造者模式 "},"CcodeSummary/CDesignMode/8.Facade.html":{"url":"CcodeSummary/CDesignMode/8.Facade.html","title":"8. 外观模式","keywords":"","body":"外观模式 "},"CcodeSummary/CDesignMode/9.Visitor.html":{"url":"CcodeSummary/CDesignMode/9.Visitor.html","title":"9. 访问者模式","keywords":"","body":"访问者模式 "},"CcodeSummary/CDesignMode/10.Atypical.html":{"url":"CcodeSummary/CDesignMode/10.Atypical.html","title":"10. 非典型模式","keywords":"","body":"非典型模式 "},"CcodeSummary/CMemory/":{"url":"CcodeSummary/CMemory/","title":"C内存-运行机制","keywords":"","body":"C内存-运行机制 "},"PHY/":{"url":"PHY/","title":"PHY","keywords":"","body":"通信-4G&5G 通信-星星之火 专题 通信-ORAN专题系列 4G+5G FAPI 通信-《信号与系统》解读 技术管理与领导 赚钱-技术人员的赚钱之道 赚钱-量化投资学习 "},"PHY/1.电磁波.html":{"url":"PHY/1.电磁波.html","title":"1. 无线电波","keywords":"","body":"电磁波概述 电磁波的产生： 变化的电场 + 变化的磁 场形成的统一场在空间传播，就形成电磁波。 电磁波的分布： 通过波长大小定义波的分布，波长从长到短（频率从小到大）分布为：无线电波，红外线，可见光，紫外线，X射线，伽马射线等。如下图所示。 无线电波： 无线电波包括长波，中波，短波，超短波和微波，频率范围为10KHz到30GHz。我们日常所用的无线AP，手机，收音机，对讲机都依靠无线电波进行数据传输。如目前使用的wifi就工作在2.4GHz和5GHz频段，再如我国5G（第五代移动通信技术）通信工作的频段为3.3GHz-3.6GHz,4.8GHz-5GHz。有人可能会担心会不会与5Gwifi形成干扰，答案是不会，因为5GHz wifi包含5.1GHz和5.8GHz左右，与第五代通信频段没有重叠。 频率越高，是否穿透力越弱？ 对于可见光以下的电磁波（包括可见光），如电磁波，满足频率越高，穿透性越弱，如5G wifi的穿墙能力没有2.4G wifi强。 对于可见光以上的地磁波，如X射线，恰恰相反，频率越强，穿透力越强，如X射线可以穿透金属。 具体原因和光子能量有关，可见光的光子能力大，足以让其他阻挡它传播的物体的粒子发生能量级跃变，所以能量被吸收了，无线电波光子能量不够，最多因为损耗失去一部分能量。而X光的光子能量更大，在使障碍物发生能级跃变之后，还有足够能量穿越障碍物。 无线电波 无线电波（英语：Radio waves）有时也称无线电、射频，是一种电磁波，其波长在电磁波谱中比红外线长。无线电波的频率在300 GHz到3 kHz之间，但也有定义将任何1 GHz或3 GHz以上的电波划为微波。当频率在300 GHz时，无线电波对应的波长为1 mm（0.039英寸）；在3 kHz时，波长为100 km（62 mi）。和其他电磁波一样，无线电波也以光速行进。 自然界中的无线电波主要是由闪电或者宇宙天体形成。 无线电波由无线电发射器产生，并由无线电接收器使用天线接收。无线电波在现代技术中广泛用于固定和移动无线电通信、广播、雷达和无线电导航、通信卫星、无线计算机网络等。不同频率的无线电波在地球大气层中具有不同的传播特性；长波可以在山脉等障碍物周围衍射并随地球表面进行传播（地波），较短的波可以从电离层被反射并传播至地平线以外（天波），而短得多的波长则很少弯曲或衍射并继续以视线传播，因此它们的传播距离仅限于地平线。 无线通信频率分配表 先看看无线电信号的频谱如何划分： 5G NR 频段 3GPP已指定5G NR 支持的频段列表，5G NR频谱范围可达100GHz，指定了两大频率范围： ①Frequency range 1 （FR1）：就是我们通常讲的6GHz以下频段 •频率范围：450MHz - 6.0GHz •最大信道带宽100MHz ②Frequency range 2 （FR2）：就是毫米波频段 •频率范围：24.25GHz - 52.6GHz •最大信道带宽400MHz 5G NR支持 16CC 载波聚合。 由于5G NR定义了灵活的子载波间隔，不同的子载波间隔对应不同的频率范围，具体如下： 5G NR频段分为：FDD、TDD、SUL和SDL。SUL和SDL为辅助频段（Supplementary Bands），分别代表上行和下行。 与LTE不同，5G NR频段号标识以“n”开头，比如LTE的B20（Band 20），5G NR称为n20。 目前3GPP已指定的5G NR频段具体如下： FR1 (450 MHz–6000MHz)： FR2： 如上图所示，5G NR包含了部分LTE 频段，也新增了一些频段。目前，全球最有可能优先部署的5G频段为n77、n78、n79、n257、n258和n260，就是3.3GHz-4.2GHz、 4.4GHz-5.0GHz和毫米波频段26GHz/28GHz/39GHz。 国内频谱分配情况 三大运营商频率划分 注： 1）黄色保护带：原移动用1880-1900（20M），电信用1860-1875（15M），由于TD和FDD之间有干扰，需留1875-1880间的5M出来做隔离带。电信把小灵通占用频段（1900-1920）清出来还给移动后，移动就拥有完整的从1880-1920的40M频段，但隔离带由移动侧出1880-1885间的5M。这样，电信就可以用1860-1880做完整的20M载波。移动用1885-1920的35M。 2）根据今年6月份《工信部同意关于中国电信使用800M和2100M频段开展LTE组网的批复》，中国电信可以在CDMA 1X/DO频段825-835/870－880，1920-1940/2110-2130上重耕LTE FDD。 3）根据最近《工信部同意关于中国联通调整部分频率用于LTE组网的批复》，中国联通可以在原2G和WCDMA频段909-915/954-960，1735-1750/1830-1845,1940-1965/2130-2155上重耕LTE FDD。 Reference 雷达波段划分 关于电磁波的几点常识 无线通信频率分配表（含最新5G NR） "},"PHY/2.4G_5G.html":{"url":"PHY/2.4G_5G.html","title":"2. 4G&5G专题","keywords":"","body":"[4G&5G专题-1]：专题导读 [4G&5G专题-2]：RRU 射频功率放大器PA与低噪声放大器LNA [4G&5G专题-3]：RRU 数字预失真DPD详解 [4G&5G专题-4]：RRU 全面了解什么是4G+5G RF静态射频共享？ [4G&5G专题-5]：RRU 全面了解什么是4G+5G RF动态频谱共享？ [4G&5G专题-6]：架构 5G的八大组网方案 [4G&5G专题-7]：RRU 首款2G/3G/4G/5G通用双通道射频芯片RFIC ADI ADRV9009、ADRV9010详解 [4G&5G专题-8]：RRU 峰均比降低技术CFR（波峰系数削减） [4G&5G专题-9]：RRU 数字上变频DUC与数字下变频DDC [4G&5G专题-9]：前传接口 CPRI与OBSAI的那些事 星星之火-56：前传接口 CPRI容器的字长、能力与CPRI速率的对应关系 星星之火-57：前传接口 CPRI的速率、能力、小区带宽之间的映射关系 [4G&5G专题-10]：前传接口 eCPRI协议的那些事 [4G&5G专题-11]：功能-什么是4G/5G的载波聚合CA? [4G&5G专题-12]：功能-LTE载波聚合CA对空口协议栈的影响概述 [4G&5G专题-13]：功能 LTE授权频谱辅助接入技术（LAA ）详解 [4G&5G专题-14]：应用层-5G的三大业务应用场景（多、快、好、省） [4G&5G专题-15]：需求-5G网络架构内在的几大特征 [4G&5G专题-16]：需求-3GPP对5G系统提出的8大维度的性能需求 [4G&5G专题-17]：需求-5G发展的主要驱动力 [4G&5G专题-18]：架构-合久必分，分久必合，无线接入网RAN的演进过程与5G无线接入网NR-RAN [4G&5G专题-19]：架构-核心网的演变以及基于服务的5G核心网网络架构 [4G&5G专题-20]：架构-降低业务延时的移动边缘计算MEC-应用服务的下沉 图解通信原理与案例分析-21：4G LTE多天线技术--天线端口、码流、分集Diveristy、波束赋形BF、空分复用MIMO、空分多址 [4G&5G专题-22]：架构-3GPP组织以及3GPP标准各个版本的演进路线 [4G&5G专题-23]：架构-5G无线接入内部网元架构与空口协议功能切分 [4G&5G专题-24]：架构-5G接入网协议栈规范 关于5G的频谱，看这一篇就够啦！ "},"PHY/3.通信原理.html":{"url":"PHY/3.通信原理.html","title":"3. 通信原理","keywords":"","body":""},"Python/":{"url":"Python/","title":"python","keywords":"","body":"Pyhton "},"Vim/":{"url":"Vim/","title":"Vim","keywords":"","body":"Vim "},"Vim/1.VimNote.html":{"url":"Vim/1.VimNote.html","title":"1. vimplus","keywords":"","body":"Vim Note vimplus 下载安装 安装 vimplus： $ git clone https://github.com/chxuan/vimplus.git ~/.vimplus $ cd ~/.vimplus $ ./install.sh 更新 vimplus： $ ./update.sh 可通过 vimplus 的 ,h 命令查看 vimplus 帮助文档 Ubuntu vimplus .vimrc 文件中有一个插件有问题，需要注释掉，插件名字如下： Plug 'Shougo/echodoc.vim' 安装 ctags 重新安装 ctags，使用 Universal CTags (默认的软件源都是Exuberant Ctags，版本太旧了) $ sudo apt install autoconf $ cd /tmp $ git clone https://github.com/universal-ctags/ctags $ cd ctags $ ./autogen.sh $ ./configure --prefix=PATH # 安装路径,自己的情况调整。 $ make $ sudo make install 生成tags文件： # 递归的为当前目录及子目录下的所有代码文件生成tags文件 (推荐使用此命令) $ ctags -R #为当前目录某些源码生成tags文件 $ ctags filename.c filename1.c file.h #为当前目录所有.c, .h源码生成tags文件 $ ctags *.c *.h 为了使得字段补全有效，在生成tags时需要一些额外的参数，推荐的c++参数主要是：ctags -R --c++-kinds=+px --fields=+iaS --extra=+q 其中： 选项c++-kinds 用于指定C++语言的 tags记录类型, --c-kinds用于指定c语言的， 通用格式是 --{language}-kinds 选项 fileds 用于指定每条标记的扩展字段域 extra 选项用于增加额外的条目: f表示为每个文件增加一个条目， q为每个类增加一个条目 注意：如果新定义或修改了函数、宏、变量，需要使用以上命令更新ctag以后才能查找到 配置 第一种方法，直接指定tags路径： 用vim打开某个工程文件，在命令行模式设置tags源，即 : set tags=/home/d/code/tags 或者 在 ~/.vimrc配置文件中添加一行 ：set tags=/home/d/code/tags 直接指定了tags文件的路径，vim直接从这个路径的tags文件查找函数或变量。不建议使用。 第二种方法，通用配置： 在 ~/.vimrc文件中添加下面两行： set tags=tags; set autochdir 这两个命令的作用：vim首先在当前目录里寻找tags文件，如果没有找到tags文件，或者没有找到对应的目标，就到父目录中查找，一直向上递归。因为tags文件中记录的路径总是相对于tags文件所在的路径，所以要使用第二个设置项来改变vim的当前目录。需要注意的是，第一个命令里的分号是必不可少的。 建议使用第二种方法，可以避免一些路径冲突或不存在导致的问题。使用第二种方法，只在代码工作目录生成一个tags文件就可以了。如果逐层多个目录生成了tags文件，使用 Ctrl + ] 查找时会显示多个相同项目。 常用命令 操作 描述 Ctrl + ] 跳转到光标所在变量、宏、函数的定义处 Ctrl + T 返回到跳转前的位置 Ctrl + W + ] 分割当前窗口，并在新窗口中显示跳转到的定义 Ctrl + O 返回之前的位置 :ts 列出所有匹配的标签 使用中可能遇到的问题 1、ctags已经安装并且tags文件也已经生成，通过 ctrl + ] 查找某个函数、宏、结构体的定义的时候，报错：“E257: cstag: tag not found”，为什么？ 可能原因有三个： （1）查找的函数、宏、结构体可能是新定义的或者有修改，tags文件还没有相应的的数据，如果确定是这种情况，需要重新执行ctags -R命令，更新tags数据，就可以找到了。 （2）如果没有在 ~/.vimrc 配置文件（或其他类似的配置文件）中添加 set tags=tags;set autochdir 这两个配置，只能从tags所在目录指定路径直接打开代码文件才管用。举个栗子：代码目录为： ~/code，某个代码文件的路径是：a/b/c.c，并且在目录~/code下执行ctags -R命令生成tags文件。这种情况下，在~/code目录使用命令：vim a/b/c.c打开文件，是可以使用Ctrl + ]找到函数定义的，但是，如果先进入目录~/code/a/b，再打开文件vim c.c，这样就会找不到tag。使用上文第二种配置方法，当前目录找不到tags时候会递归向上一级目录查找，可以避免这个问题。 （3）还有一种可能是tags配置路径不对应导致，如果指定了固定的tags路径，需要确保路径存在并且此路径下存在tags文件 检查每个vim相关的配置文件（比如/etc/vim/vimrc和~/.vimrc等）中的set tags配置项，确保路径不冲突 比如：~/.vimrc下有这样的配置：set tags=/data/nginx/tags，而自己的tags文件在 ~/code目录下，路径不一致，找不到就会报错：“E257: cstag: tag not found”， 还有比如，存在两个配置：set tags=/home/test1/tags set tags=/home/test2/tags，而/home/test2没有tags，也会报错。 总之，如果set tags配置了固定的路径，一定要与tags文件路径保持一致。如果每个人都是在不同主机开发或者是同一主机但不同用户下开发，不会有这种情况出现，但如果是多人共用一个开发环境使用同一用户，只是代码所在路径不同就可能发生，亲身经历过的。 2、使用 Ctrl + ] 查找某个标签时，第一次查找时列出了所有匹配项选择一个后，但在第二次查找时却直接跳转到之前选择过的项而不是列出所有的匹配项，或者使用 Ctrl + ] 查找标签时总是直接跳转到第一个匹配的标签，但这可能并不是你想要的，这时候使用 :ts命令就可以列出所有匹配项供自己选择，或者在配置文件中添加如下配置：map g。 安装 gtags 请首先安装最新版本 gtags，目前版本是 6.6.2，Linux 下请自行编译最新版（Debian / Ubuntu 自带的都太老了），Mac 下检查下 brew 安装的版本至少不要低于 6.6.0 ，否则请自己编译。 安装 gtags (系统软件源一般版本比较低，建议自己编译安装) gtags 原生支持 6 种语言（C，C++，Java，PHP4，Yacc，汇编）， 通过安装 pygments 扩展支持 50+ 种语言（包括 go/rust/scala 等，基本覆盖所有主流语言）。 $ pip install pygments # $ sudo apt install global # 安装gtags 保证 .vimrc 里要设置过两个环境变量才能正常工作： \" vimrc 中设置环境变量启用 pygments let $GTAGSLABEL = 'native-pygments' let $GTAGSCONF = '/path/to/share/gtags/gtags.conf' 第一个 GTAGSLABEL 告诉 gtags 默认 C/C++/Java 等六种原生支持的代码直接使用 gtags 本地分析器，而其他语言使用 pygments 模块。 第二个环境变量必须设置，否则会找不到 native-pygments 和 language map 的定义，Linux 下要到 /usr/local/share/gtags 里找，也可以把它拷贝成 ~/.globalrc ，Vim 配置的时候方便点。 实际使用 pygments 时，gtags 会启动 python 运行名为 pygments_parser.py 的脚本，通过管道和它通信，完成源代码分析，故需保证 gtags 能在 $PATH 里调用 python，且这个 python 安装了 pygments 模块。 正确安装后，可以通过命令行 gtags 命令和 global 进行测试，注意shell 下设置环境变量。 安装三个插件 安装三个插件 : vim-gutentags 索引自动管理 + 索引数据库切换 + 索引预览 \" 静态语法检查插件 Plug 'w0rp/ale' \" Vim自动生成 tags 插件 vim-gutentag Plug 'ludovicchabant/vim-gutentags' Plug 'skywind3000/gutentags_plus' Plug 'skywind3000/vim-preview' 自动生成 Gtags 使用 vim-gutentags 插件。 Plug 'ludovicchabant/vim-gutentags' .vimrc 里加入： \" gutentags 搜索工程目录的标志，当前文件路径向上递归直到碰到这些文件/目录名 let g:gutentags_project_root = ['.root', '.svn', '.git', '.hg', '.project'] \" 所生成的数据文件的名称 let g:gutentags_ctags_tagfile = '.tags' \" 同时开启 ctags 和 gtags 支持： let g:gutentags_modules = [] if executable('ctags') let g:gutentags_modules += ['ctags'] endif if executable('gtags-cscope') && executable('gtags') let g:gutentags_modules += ['gtags_cscope'] endif \" 将自动生成的 tags 文件全部放入 ~/.cache/tags 目录中，避免污染工程目录 let s:vim_tags = expand('~/.cache/tags') let g:gutentags_cache_dir = s:vim_tags \" 配置 ctags 的参数，老的 Exuberant-ctags 不能有 --extra=+q，注意 let g:gutentags_ctags_extra_args = ['--fields=+niazS', '--extra=+q'] let g:gutentags_ctags_extra_args += ['--c++-kinds=+px'] let g:gutentags_ctags_extra_args += ['--c-kinds=+px'] \" 如果使用 universal ctags 需要增加下面一行，老的 Exuberant-ctags 不能加下一行 let g:gutentags_ctags_extra_args += ['--output-format=e-ctags'] \" 禁用 gutentags 自动加载 gtags 数据库的行为 let g:gutentags_auto_add_gtags_cscope = 0 \" 检测 ~/.cache/tags 不存在就新建 if !isdirectory(s:vim_tags) silent! call mkdir(s:vim_tags, 'p') endif \" 预览 quickfix 窗口 ctrl-w z 关闭 \" p 预览 大p关闭 autocmd FileType qf nnoremap p :PreviewQuickfix autocmd FileType qf nnoremap P :PreviewClose \" 往上滚动预览窗口 noremap u :PreviewScroll -1 \" 往下滚动预览窗口 noremap d :PreviewScroll +1 基于 gutentags 实现跳转 在为当前目录生成tags文件后，可以通过按键 Ctrl + ] 跳转到对应的定义位置，再使用命令 Ctrl + o 回退到原来的位置。关于跳转的具体应用，可以参考 Vim使用ctags实现函数跳转 另外，建议多使用 Ctrl + W + ] 用新窗口打开并查看光标下符号的定义，或者 Ctrl -W } 使用 preview 窗口预览光标下符号的定义。 预设快捷键如下 快捷键 说明 cg 查看光标下符号的定义 cs 查看光标下符号的引用 cc 查看有哪些函数调用了该函数 cf 查找光标下的文件 ci 查找哪些文件 include 了本文件 查找到索引后跳到弹出的 quikfix 窗口，停留在想查看索引行上，按 小P 直接打开预览窗口，大P 关闭预览。 快速预览 我们从新项目仓库里查询了一个符号的引用，gtags 噼里啪啦的给了你二十多个结果，那么多结果顺着一个个打开，查看，关闭，再打开很蛋疼，可使用 vim-preview 插件高效的在 quickfix 中先快速预览所有结果，再有针对性的打开必要文件： Plug 'skywind3000/vim-preview' 快捷键 以下是部分常用快捷键，可通过 vimplus 的 ,h 命令查看 vimplus帮助文档。 快捷键 说明 n 打开/关闭代码资源管理器 t 打开/关闭函数列表 a .h .cpp 文件切换 u 转到函数声明 U 转到函数实现 u 转到变量声明 o 打开include文件 y 拷贝函数声明 p 生成函数实现 w 单词跳转 f 搜索~目录下的文件 F 搜索当前目录下的文本 ff 语法错误自动修复(FixIt) 切换到上一个buffer 切换到下一个buffer d 删除当前buffer D 删除当前buffer外的所有buffer 显示语法错误提示窗口 l 按竖线对齐 = 按等号对齐 Ya 复制行文本到字母a Da 剪切行文本到字母a Ca 改写行文本到字母a rr 替换文本 r 全局替换，目前只支持单个文件 rev 翻转当前光标下的单词或使用V模式选择的文本 gcc 注释代码 gcap 注释段落 vif 选中函数内容 dif 删除函数内容 cif 改写函数内容 vaf 选中函数内容（包括函数名 花括号） daf 删除函数内容（包括函数名 花括号） caf 改写函数内容（包括函数名 花括号） fa 查找字母a，然后再按f键查找下一个 h 打开vimplus帮助文档 H 打开当前光标所在单词的vim帮助文档 t 生成try-catch代码块 y 复制当前选中到系统剪切板 i 安装插件 u 更新插件 c 删除插件 缓存操作 快捷键 说明 :e 新建buffer打开文件 :bp 切换到上一个buffer :bn 切换到下一个buffer :bd 删除当前buffer 窗口操作 快捷键 说明 :sp 横向切分窗口并打开文件 :vsp 竖向切分窗口并打开文件 h 跳到左边的窗口 j 跳到下边的窗口 k 跳到上边的窗口 l 跳到右边的窗口 c 关闭当前窗口 o 关闭其他窗口 :only 关闭其他窗口 光标移动 快捷键 说明 0 光标移动到行首 ^ 跳到从行首开始第一个非空白字符 $ 光标移动到行尾 跳到上一个位置 跳到下一个位置 上一页 下一页 上移半屏 下移半屏 H 调到屏幕顶上 M 调到屏幕中间 L 调到屏幕下方 :n 跳到第n行 w 跳到下一个单词开头(标点或空格分隔的单词) W 跳到下一个单词开头(空格分隔的单词) e 跳到下一个单词尾部(标点或空格分隔的单词) E 跳到下一个单词尾部(空格分隔的单词) b 上一个单词头(标点或空格分隔的单词) B 上一个单词头(空格分隔的单词) ge 上一个单词尾 % 在配对符间移动, 可用于()、{}、[] gg 到文件首 G 到文件尾 fx 跳转到下一个为x的字符 Fx 跳转到上一个为x的字符 tx 跳转到下一个为x的字符前 Tx 跳转到上一个为x的字符前 ; 跳到下一个搜索的结果 [[ 跳转到函数开头 ]] 跳转到函数结尾 文本编辑 快捷键 说明 r 替换当前字符 R 进入替换模式，直至 ESC 离开 s 替换字符（删除光标处字符，并进入插入模式，前可接数量） S 替换行（删除当前行，并进入插入模式，前可接数量） cc 改写当前行（删除当前行并进入插入模式），同 S cw 改写光标开始处的当前单词 ciw 改写光标所处的单词 caw 改写光标所处的单词，并且包括前后空格（如果有的话） ct, 改写到逗号 c0 改写到行首 c^ 改写到行首（第一个非零字符） c$ 改写到行末 C 改写到行末（同 c$） ci\" 改写双引号中的内容 ci' 改写单引号中的内容 ci) 改写小括号中的内容 ci] 改写中括号中内容 ci} 改写大括号中内容 cit 改写 xml tag 中的内容 cis 改写当前句子 ciB 改写'{}'中的内容 c2w 改写下两个单词 ct( 改写到小括号前 x 删除当前字符，前面可以接数字，3x代表删除三个字符 X 向前删除字符 dd 删除当前行 d0 删除到行首 d^ 删除到行首（第一个非零字符） d$ 删除到行末 D 删除到行末（同 d$） dw 删除当前单词 dt, 删除到逗号 diw 删除光标所处的单词 daw 删除光标所处的单词，并包含前后空格（如果有的话） di\" 删除双引号中的内容 di' 删除单引号中的内容 di) 删除小括号中的内容 di] 删除中括号中内容 di} 删除大括号中内容 diB 删除'{}'中的内容 dit 删除 xml tag 中的内容 dis 删除当前句子 d2w 删除下两个单词 dt( 删除到小括号前 dgg 删除到文件头部 dG 删除到文件尾部 d} 删除下一段 d{ 删除上一段 u 撤销 U 撤销整行操作 CTRL-R 撤销上一次 u 命令 J 连接若干行 gJ 连接若干行，删除空白字符 . 重复上一次操作 ~ 交换大小写 g~iw 替换当前单词的大小写 gUiw 将单词转成大写 guiw 将当前单词转成小写 guu 全行转为小写 gUU 全行转为大写 gg=G 缩进整个文件 =a{ 缩进光标所在代码块 =i{ 缩进光标所在代码块，不缩进\"{\" 减少缩进 >> 增加缩进 == 自动缩进 CTRL-A 增加数字 CTRL-X 减少数字 p 粘贴到光标后 P 粘贴到光标前 v 开始标记 y 复制标记内容 V 开始按行标记 CTRL-V 开始列标记 y$ 复制当前位置到本行结束的内容 yy 复制当前行 Y 复制当前行，同 yy yt, 复制到逗号 yiw 复制当前单词 \"+y 复制当前选中到系统剪切板 3yy 复制光标下三行内容 v0 选中当前位置到行首 v$ 选中当前位置到行末 vt, 选中到逗号 viw 选中当前单词 vi) 选中小括号内的东西 vi] 选中中括号内的东西 viB 选中'{}'中的内容 vis 选中句子中的东西 gv 重新选择上一次选中的文字 :set paste 允许粘贴模式（避免粘贴时自动缩进影响格式） :set nopaste 禁止粘贴模式 \"?yy 复制当前行到寄存器 ? ，问号代表 0-9 的寄存器名称 \"?p 将寄存器 ? 的内容粘贴到光标后 \"?P 将寄存器 ? 的内容粘贴到光标前 :registers 显示所有寄存器内容 :[range]y 复制范围，比如 :20,30y 是复制20到30行，:10y 是复制第十行 :[range]d 删除范围，比如 :20,30d 是删除20到30行，:10d 是删除第十行 ddp 交换两行内容：先删除当前行复制到寄存器，并粘贴 文件操作 快捷键 说明 :w 按名称保存文件 ZZ 保存文件（如果有改动的话），并关闭窗口 :e 打开文件并编辑 :saveas 另存为文件 :r 读取文件并将内容插入到光标后 :r !dir 将dir命令的输出捕获并插入到光标后 :wa 保存所有文件 :cd 切换Vim当前路径 :new 打开一个新的窗口编辑新文件 :enew 在当前窗口创建新文件 :vnew 在左右切分的新窗口中编辑新文件 :tabnew 在新的标签页中编辑新文件 实用命令 快捷键 说明 /pattern 从光标处向文件尾搜索 pattern ?pattern 从光标处向文件头搜索 pattern n 向同一方向执行上一次搜索 N 向相反方向执行上一次搜索 * 向前搜索光标下的单词 # 向后搜索光标下的单词 :s/p1/p2/g 替换当前行的p1为p2 :%s/p1/p2/g 替换当前文件中的p1为p2 :%s//p2/g 替换当前文件中的p1单词为p2 :%s/p1/p2/gc 替换当前文件中的p1为p2，并且每处询问你是否替换 :10,20s/p1/p2/g 将第10到20行中所有p1替换为p2 :%s/1\\\\2\\/3/123/g 将“1\\2/3” 替换为 “123”（特殊字符使用反斜杠标注） :%s/\\r//g 删除 DOS 换行符 ^M :g/^\\s*$/d 删除空行 :g/test/d 删除所有包含 test 的行 :v/test/d 删除所有不包含 test 的行 :%s/^/test/ 在行首加入特定字符(也可以用宏录制来添加) :%s/$/test/ 在行尾加入特定字符(也可以用宏录制来添加) :sort 排序 :g/^\\(.\\+\\)$\\n\\1/d 去除重复行(先排序) :%s/^.\\{10\\}// 删除每行前10个字符 :%s/.\\{10\\}$// 删除每行尾10个字符 其他 快捷键 说明 vim -u NONE -N 开启vim时不加载vimrc文件 vimdiff file1 file2 显示文件差异 vim -R filename 以只读方式打开（阅读模式） Reference Vim配置) 2018 更新下vim 插件 Vim 8 中 C/C++ 符号索引：GTags 篇 Vim自动生成tags插件vim-gutentags安装和自动跳转方法-Vim插件(10) 在Vim中使用gtags 源码阅读工具之Global) ubuntu14.04编译gnu global 6.6.3 vimplus -- Github Vim使用笔记 "},"Vim/2.vimHotKey.html":{"url":"Vim/2.vimHotKey.html","title":"2. vim 快捷键","keywords":"","body":"Vim 快捷键 vimplus github Vim使用笔记 利用ctags+cscope+taglist+nerdree+srcexpl+trinity 将 VIM 变成 source insight 1. 文档操作 快捷键 说明 :e 重新加载当前文档 :e! 重新加载当前文档，并丢弃已做的改动 :e file 关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi 会警告 :e! file 放弃对当前文件的修改，编辑新的文件 :e# 或 ctrl+^ 回到刚才编辑的文件，很实用 gf 打开以光标所在字符串为文件名的文件 :saveas newfilename 另存为 2. 光标的移动 gj : 移动到一段内的下一行； gk : 移动到一段内的上一行； w : 前移一个单词，光标停在下一个单词开头； b : 后移一个单词，光标停在上一个单词开头； ( : 前移1句。 ) : 后移1句。 { : 前移1段。 } : 后移1段。 fc : 把光标移到同一行的下一个 c 字符处 Fc : 把光标移到同一行的上一个 c 字符处 tc : 把光标移到同一行的下一个 c 字符前 Tc : 把光标移到同一行的上一个 c 字符后 ; : 配合 f & t 使用，重复一次 , : 配合 f & t 使用，反向重复一次 上面的操作都可以配合 n 使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动 3 个字符。 0 : 移动到行首。 g0 : 移到光标所在屏幕行行首。 ^ : 移动到本行第一个非空白字符。 g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。 $ : 移动到行尾。 g$ : 移动光标所在屏幕行行尾。 n| : 把光标移到递 n 列上。 nG : 到文件第 n 行。 :n : 移动到第 n 行。 :$ : 移动到最后一行。 H : 把光标移到屏幕最顶端一行。 M : 把光标移到屏幕中间一行。 L : 把光标移到屏幕最底端一行。 gg : 到文件头部。 G : 到文件尾部。 2.1 翻屏 ctrl+f : 下翻一屏。 ctrl+b : 上翻一屏。 ctrl+d : 下翻半屏。 ctrl+u : 上翻半屏。 ctrl+e : 向下滚动一行。 ctrl+y : 向上滚动一行。 n% : 到文件 n% 的位置。 zz : 将当前行移动到屏幕中央。 zt : 将当前行移动到屏幕顶端。 zb : 将当前行移动到屏幕底端。 2.2 标记 使用标记可以快速移动。到达标记后，可以用 Ctrl+o 返回原来的位置。 Ctrl+o 和 Ctrl+i 很像浏览器上的 后退 和 前进 。 m{a-z} : 标记光标所在位置，局部标记，只用于当前文件。 m{A-Z} : 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。 `{a-z} : 移动到标记位置。 '{a-z} : 移动到标记行的行首。 `{0-9} ：回到上[2-10]次关闭vim时最后离开的位置。 ``: 移动到上次编辑的位置。'' 也可以，不过``精确到列，而 '' 精确到行 。如果想跳转到更老的位置，可以按 C-o，跳转到更新的位置用 C-i。 `\" : 移动到上次离开的地方。 `. : 移动到最后改动的地方。 :marks -- 显示所有标记。 :delmarks a b -- 删除标记 a 和 b。 :delmarks a-c -- 删除标记 a、b 和 c。 :delmarks a c-f -- 删除标记 a、c、d、e、f。 :delmarks! -- 删除当前缓冲区的所有标记。 :help mark-motions -- 查看更多关于 mark 的知识。 3. 插入文本 3.1 基本插入 i : 在光标前插入；一个小技巧：按 8，再按 i，进入插入模式，输入 =， 按 esc 进入命令模式，就会出现 8 个 = 。 这在插入分割线时非常有用，如30i+ 就插入了 36 个 + 组成的分割线。 :r filename : 在当前位置插入另一个文件的内容。 :r !date : 在光标处插入当前日期与时间。同理，:r !command 可以将其它 shell 命令的输出插入当前文档。 3.2 改写插入 c[n]w : 改写光标后 1(n) 个词。 c[n]l : 改写光标后 n 个字母。 c[n]h : 改写光标前 n 个字母。 [n]cc : 修改当前 [n] 行。 [n]s : 以输入的文本替代光标之后 1(n) 个字符，相当于 c[n]l。 [n]S : 删除指定数目的行，并以所输入文本代替之。 注意，类似 cnw,dnw,ynw 的形式同样可以写为 ncw,ndw,nyw。 4. 剪切复制和寄存器 4.1 剪切和复制、粘贴 [n]x : 剪切光标右边 n 个字符，相当于 d[n]l。 [n]X : 剪切光标左边 n 个字符，相当于 d[n]h。 y : 复制在可视模式下选中的文本。 yy or Y : 复制整行文本。 y[n]w : 复制一 (n) 个词。 y[n]l : 复制光标右边 1(n) 个字符。 y[n]h : 复制光标左边 1(n) 个字符。 y$ : 从光标当前位置复制到行尾。 y0 : 从光标当前位置复制到行首。 :m,ny : 复制 m 行到 n 行的内容。 y1G 或 ygg : 复制光标以上的所有行。 yG : 复制光标以下的所有行。 yaw 和 yas：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。 d : 删除（剪切）在可视模式下选中的文本。 d$ or D : 删除（剪切）当前位置到行尾的内容。 d[n]w: 删除（剪切）1(n)个单词 d[n]l: 删除（剪切）光标右边 1(n) 个字符。 d[n]h: 删除（剪切）光标左边 1(n) 个字符。 d0: 删除（剪切）当前位置到行首的内容 [n] dd: 删除（剪切）1(n) 行。 :m,nd : 剪切 m 行到 n 行的内容。 d1G 或 dgg : 剪切光标以上的所有行。 dG : 剪切光标以下的所有行。 daw 和 das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。 d/f：这是一个比较高级的组合命令，它将删除当前位置 到下一个 f 之间的内容。 p: 在光标之后粘贴。 P : 在光标之前粘贴。 4.2 文本对象 aw：一个词 as：一句。 ap：一段。 ab：一块（包含在圆括号中的）。 y, d, c, v 都可以跟文本对象。 4.3 寄存器 a-z：都可以用作寄存器名。\"ayy 把当前行的内容放入 a 寄存器。 A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如 \"Ayy 把当前行的内容追加到 a 寄存器中。 :reg : 显示所有寄存器的内容。 \"\"：不加寄存器索引时，默认使用的寄存器。 \"*：当前选择缓冲区，\"*yy 把当前行的内容放入当前选择缓冲区。 \"+：系统剪贴板。\"+yy 把当前行的内容放入系统剪贴板。 5. 查找与替换 5.1 查找 /something : 在后面的文本中查找 something。 ?something : 在前面的文本中查找 something。 /pattern/+number : 将光标停在包含 pattern 的行后面第 number 行上。 /pattern/-number : 将光标停在包含 pattern 的行前面第 number 行上。 n : 向后查找下一个。 N : 向前查找下一个。 可以用 grep 或 vimgrep 查找一个模式都在哪些地方出现过，其中 :grep 是调用外部的 grep 程序，而 :vimgrep 是 vim 自己的查找算法。 用法为： :vim[grep]/pattern/[g] [j] files g 的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。 j 的含义是 grep 结束后，结果停在第 j 项，默认是停在第一项。 vimgrep 前面可以加数字限定搜索结果的上限，如 :1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。 其实 vimgrep 在读纯文本电子书时特别有用，可以生成导航的目录。 比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：:vim/^d{1,}./ % 然后用 :cw 或 :copen 查看结果，可以用 C-w H 把 quickfix 窗口移到左侧，就更像个目录了。 5.2 替换 :s/old/new -- 用 new 替换当前行第一个 old。 :s/old/new/g -- 用 new 替换当前行所有的 old。 :n1,n2s/old/new/g -- 用 new 替换文件 n1 行到 n2 行所有的 old。 :%s/old/new/g -- 用 new 替换文件中所有的 old。 :%s/^/xxx/g -- 在每一行的行首插入 xxx，^ 表示行首。 :%s/$/xxx/g -- 在每一行的行尾插入 xxx，$ 表示行尾。 所有替换命令末尾加上 c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。 还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令， 语法为 :[range]g/pattern/command 例如 : %g/^ xyz/normal dd。 表示对于以一个空格和 xyz 开头的行执行 normal 模式下的 dd 命令。 关于 range 的规定为： 如果不指定 range，则表示当前行。 m,n : 从 m 行到 n 行。 0 : 最开始一行（可能是这样）。 $ : 最后一行 . : 当前行 % : 所有行 5.3 正则表达式 高级的查找替换就要用到正则表达式。 \\d : 表示十进制数（我猜的） \\s : 表示空格 \\S : 非空字符 \\a : 英文字母 \\| : 表示 或 \\. : 表示. {m,n} : 表示 m 到 n 个字符。这要和 \\s 与 \\a 等连用，如 \\a\\{m,n} 表示 m 到 n 个英文字母。 {m,}: 表示 m 到无限多个字符。 **: 当前目录下的所有子目录。 :help pattern 得到更多帮助。 6. 编辑多个文件 6.1 一次编辑多个文件 我们可以一次打开多个文件，如 $ vi a.txt b.txt c.txt 使用 :next(:n) 编辑下一个文件。 :2n 编辑下 2 个文件。 使用 :previous或:N 编辑上一个文件。 使用 :wnext，保存当前文件，并编辑下一个文件。 使用 :wprevious，保存当前文件，并编辑上一个文件。 使用 :args 显示文件列表。 :n filenames 或 :args filenames 指定新的文件列表。 vi -o filenames 在水平分割的多个窗口中编辑多个文件。 vi -O filenames 在垂直分割的多个窗口中编辑多个文件。 6.2 多标签编辑 vim -p files : 打开多个文件，每个文件占用一个标签页。 :tabe, tabnew -- 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。 ^w gf -- 在新的标签页里打开光标下路径指定的文件。 :tabn -- 切换到下一个标签。Control + PageDown，也可以。 :tabp -- 切换到上一个标签。Control + PageUp，也可以。 [n] gt -- 切换到下一个标签。如果前面加了 n ， 就切换到第 n 个标签。第一个标签的序号就是 1。 :tab split -- 将当前缓冲区的内容在新页签中打开。 :tabc[lose] -- 关闭当前的标签页。 :tabo[nly] -- 关闭其它的标签页。 :tabs -- 列出所有的标签页和它们包含的窗口。 :tabm[ove] [N] -- 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。 6.3 缓冲区 :buffers 或 :ls 或 :files 显示缓冲区列表。 ctrl+^：在最近两个缓冲区间切换。 :bn -- 下一个缓冲区。 :bp -- 上一个缓冲区。 :bl -- 最后一个缓冲区。 :b[n] 或 :[n]b -- 切换到第 n 个缓冲区。 :nbw(ipeout) -- 彻底删除第 n 个缓冲区。 :nbd(elete) -- 删除第 n 个缓冲区，并未真正删除，还在 unlisted 列表中。 :ba[ll] -- 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。 7. 分屏编辑 vim -o file1 file2 : 水平分割窗口，同时打开 file1 和 file2 vim -O file1 file2 : 垂直分割窗口，同时打开 file1 和 file2 7.1 水平分割 :split(:sp) -- 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S 可能会冻结终端，请按 CTRL-Q 继续。 :split filename -- 水平分割窗口，并在新窗口中显示另一个文件。 :nsplit(:nsp) -- 水平分割出一个 n 行高的窗口。 :[N]new -- 水平分割出一个N行高的窗口，并编辑一个新文件。 ( CTRL-W n 或 CTRL-W CTRL-N) ctrl+w f --水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。 C-w C-^ -- 水平分割一个窗口，打开刚才编辑的文件。 7.2 垂直分割 :vsplit(:vsp) -- 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v 或 CTRL CTRL-V) :[N]vne[w] -- 垂直分割出一个新窗口。 :vertical 水平分割的命令： 相应的垂直分割。 7.3 关闭子窗口 :qall -- 关闭所有窗口，退出 vim。 :wall -- 保存所有修改过的窗口。 :only -- 只保留当前窗口，关闭其它窗口。(CTRL-W o) :close -- 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x 同样工作 ) 7.4 调整窗口大小 ctrl+w + --当前窗口增高一行。也可以用 n 增高 n 行。 ctrl+w - --当前窗口减小一行。也可以用 n 减小 n 行。 ctrl+w _ --当前窗口扩展到尽可能的大。也可以用 n 设定行数。 :resize n -- 当前窗口 n 行高。 ctrl+w = -- 所有窗口同样高度。 n ctrl+w _ -- 当前窗口的高度设定为 n 行。 ctrl+w --当前窗口减少一列。也可以用 n 减少 n 列。 ctrl+w > --当前窗口增宽一列。也可以用 n 增宽 n 列。 ctrl+w | --当前窗口尽可能的宽。也可以用 n 设定列数。 7.5 切换和移动窗口 如果支持鼠标，切换和调整子窗口的大小就简单了。 ctrl+w ctrl+w : 切换到下一个窗口。或者是 ctrl+w w。 ctrl+w p : 切换到前一个窗口。 ctrl+w h(l,j,k) :切换到左（右，下，上）的窗口。 ctrl+w t(b) :切换到最上（下）面的窗口。 ctrl+w H(L,K,J) : 将当前窗口移动到最左（右、上、下）面。 ctrl+w r：旋转窗口的位置。 ctrl+w T : 将当前的窗口移动到新的标签页上。 8. 快速编辑 8.1 改变大小写 ~ : 反转光标所在字符的大小写。 可视模式下的 U 或 u：把选中的文本变为大写或小写。 gu(U) 接范围（如$，或 G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如 gu5j，把当前行和下面四行全部变成小写。 8.2 替换（normal模式） r : 替换光标处的字符，同样支持汉字。 R : 进入替换模式，按 esc 回到正常模式。 8.3 撤消与重做（normal模式） [n] u : 取消一(n)个改动。 :undo 5 -- 撤销 5 个改变。 :undolist -- 你的撤销历史。 ctrl + r : 重做最后的改动。 U : 取消当前行中所有的改动。 :earlier 4m -- 回到 4 分钟前 :later 55s -- 前进 55 秒 8.4 宏 . --重复上一个编辑动作 qa：开始录制宏 a（键盘操作记录） q：停止录制 @a：播放宏 a 9. 编辑特殊文件 9.1 文件加解密 vim -x file : 开始编辑一个加密的文件。 :X -- 为当前文件设置密码。 :set key= -- 去除文件的密码。 这里是 滇狐总结的比较高级的 vi 技巧。 9.2 文件的编码 :e ++enc=utf8 filename, 让 vim 用 utf-8 的编码打开这个文件。 :w ++enc=gbk，不管当前文件什么编码，把它转存成 gbk 编码。 :set fenc 或 :set fileencoding，查看当前文件的编码。 在 vimrc 中添加 set fileencoding=ucs-bom,utf-8,cp936，vim 会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936 对应于 gbk 编码。 ucs-bom 对应于 windows 下的文件格式。 让 vim 正确处理文件格式和文件编码，有赖于 ~/.vimrc的正确配置 9.3 文件格式 大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。 :e ++ff=dos filename, 让 vim 用 dos 格式打开这个文件。 :w ++ff=mac filename, 以 mac 格式存储这个文件。 :set ff，显示当前文件的格式。 在 vimrc 中添加 set fileformats=unix,dos,mac，让 vim 自动识别文件格式。 10. 编程辅助 10.1 一些按键 gd : 跳转到局部变量的定义处； gD : 跳转到全局变量的定义处，从当前文件开头开始搜索； g; : 上一个修改过的地方； g, : 下一个修改过的地方； [[ : 跳转到上一个函数块开始，需要有单独一行的 {。 ]] : 跳转到下一个函数块开始，需要有单独一行的 {。 [] : 跳转到上一个函数块结束，需要有单独一行的 }。 ][ : 跳转到下一个函数块结束，需要有单独一行的 }。 [{ : 跳转到当前块开始处； ]} : 跳转到当前块结束处； [/ : 跳转到当前注释块开始处； ]/ : 跳转到当前注释块结束处； % : 不仅能移动到匹配的 (),{} 或 []上，而且能在 #if，#else， #endif 之间跳跃。 下面的括号匹配对编程很实用的。 ci', di', yi'：修改、剪切或复制 ' 之间的内容。 ca', da', ya'：修改、剪切或复制 ' 之间的内容，包含 '。 ci\", di\", yi\"：修改、剪切或复制 \" 之间的内容。 ca\", da\", ya\"：修改、剪切或复制 \" 之间的内容，包含 \"。 ci(, di(, yi(：修改、剪切或复制 ()之间的内容。 ca(, da(, ya(：修改、剪切或复制 () 之间的内容，包含 ()。 ci[, di[, yi[：修改、剪切或复制 [] 之间的内容。 ca[, da[, ya[：修改、剪切或复制 []之间的内容，包含 []。 ci{, di{, yi{：修改、剪切或复制 {} 之间的内容。 ca{, da{, ya{：修改、剪切或复制 {} 之间的内容，包含 {}。 ci：修改、剪切或复制 <> 之间的内容。 ca：修改、剪切或复制 <> 之间的内容，包含<>。 10.2 ctags Ctrl + ] 找到光标所在位置的标签定义的地方 Ctrl + t 回到跳转之前的标签处 Ctrl + o 退回原来的地方 [I 查找全局标识符. Vim会列出它所找出的匹配行，不仅在当前文件内查找，还会在所有的包含文件中查找 [i 从当前文件起始位置开始查找第一处包含光标所指关键字的位置 ]i 类似上面的 [i，但这里是从光标当前位置开始往下搜索 [{ 转到上一个位于第一列的”{“。（前提是 “{” 和 “}” 都在第一列。） ]} 转到下一个位于第一列的”}” Ctrl+＼+ s 会出现所有调用、定义该函数的地方，输入索引号，回车即可 [ + ctrl + i 跳转到函数、变量和 #define 用 ctrl+o 返回 [ + ctrl + d 跳转到 #define 处用 ctrl+o 返回 ctags -R : 生成 tag 文件，-R 表示也为子目录中的文件生成 tags :set tags=path/tags -- 告诉 ctags 使用哪个 tag 文件 :tag xyz -- 跳到 xyz 的定义处，或者将光标放在 xyz 上按 C-]，返回用 C-t :stag xyz -- 用分割的窗口显示 xyz 的定义，或者 C-w ]， 如果用 C-w n ]，就会打开一个 n 行高的窗口 :ptag xyz -- 在预览窗口中打开 xyz 的定义，热键是 C-w }。 :pclose -- 关闭预览窗口。热键是 C-w z。 :pedit abc.h -- 在预览窗口中编辑 abc.h :psearch abc -- 搜索当前文件和当前文件 include 的文件，显示包含 abc 的行。 有时一个 tag 可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。 :[n]tnext -- 下一 [n] 个匹配。 :[n]tprev -- 上一 [n]个匹配。 :tfirst -- 第一个匹配 :tlast -- 最后一个匹配 :tselect tagname -- 打开选择列表 tab 键补齐 :tag xyz -- 补齐以 xyz 开头的 tag 名，继续按 tab 键，会显示其他的。 :tag /xyz -- 会用名字中含有 xyz 的 tag 名补全。 ctags 对 c++ 生成 tags : ctags -R --c++-kinds=+p --fields=+iaS --extra=+q 每个参数解释如下： -R : ctags 循环生成子目录的 tags --c++-kinds=+px : ctags 记录 c++ 文件中的函数声明和各种外部和前向声明 --fields=+iaS : ctags 要求描述的信息 其中 i 表示如果有继承，则标识出父类； a 表示如果元素是类成员的话，要标明其调用权限（即是 public 还是 private）； S 表示如果是函数，则标识函数的 signature。 --extra=+q : 强制要求 ctags 做如下操作—如果某个语法元素是类的一个成员，ctags 默认会给其记录一行，可以要求 ctags 对同一个语法元斯屹记一行，这样可以保证在 VIM 中多个同名函数可以通过路径不同来区分。 10.3 cscope 查看阅读 c++ 代码 cscope 缺省只解析 C 文件 (.c 和 .h)、lex 文件( .l )和 yacc 文件( .y )，虽然它也可以支持 C++ 以及 Java，但它在扫描目录时会跳过 C++ 及 Java 后缀的文件。如果希望 cscope 解析 C++ 或 Java 文件，需要把这些文件的名字和路径保存在一个名为 cscope.files 的文件。当 cscope 发现在当前目录中存在 cscope.files 时，就会为 cscope.files 中列出的所有文件生成索引数据库。 下面的命令会查找当前目录及子目录中所有后缀名为 \".h\", \".c\", \"cc\" 和 \".cpp\" 的文件，并把查找结果重定向到文件 cscope.files 中。然后 cscope 根据 cscope.files 中的所有文件，生成符号索引文件。最后一条命令使用 ctags 命令，生成一个 tags 文件，在 vim 中执行 \":help tags\" 命令查询它的用法。它可以和 cscope 一起使用。 $ find . -name \"*.h\" -o -name \"*.c\" -o -name \"*.cc\" -o \"*.cpp\" > cscope.files $ cscope -bkq -i cscope.files $ ctags -R cscope -Rbq : 生成 cscope.out 文件 :cs add /path/to/cscope.out /your/work/dir :cs find c func -- 查找 func 在哪些地方被调用 s: 查找 C 语言符号，即查找函数名、宏、枚举值等出现的地方 g: 查找函数、宏、枚举等定义的位置，类似 ctags 所提供的功能 d: 查找本函数调用的函数 c: 查找调用本函数的函数 t: 查找指定的字符串 e: 查找 egrep 模式，相当于 egrep 功能，但查找速度快多了 f: 查找并打开文件，类似 vim 的 find 功能 i: 查找包含本文件的文件 :cw -- 打开 quickfix 窗口查看结果 10.4 gtags Gtags 综合了 ctags 和 cscope 的功能。 使用 Gtags 之前，你需要安装 GNU Gtags。 然后在工程目录运行 gtags 。 :Gtags funcname 定位到 funcname 的定义处。 :Gtags -r funcname 查询 funcname被引用的地方。 :Gtags -s symbol 定位 symbol 出现的地方。 :Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。 :Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。 :Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P /vm/ 显示 vm 目录下的文件。 10.5 编译 vim 提供了 :make 来编译程序，默认调用的是 make， 如果你当前目录下有 makefile，简单地 :make 即可。 如果你没有 make 程序，你可以通过配置 makeprg 选项来更改 make 调用的程序。 如果你只有一个 abc.java 文件，你可以这样设置： set makeprg=javac\\ abc.java 然后 :make 即可。如果程序有错，可以通过 quickfix 窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让 vim 识别错误信息。 如： :setl efm=%A%f:%l:\\ %m,%-Z%p^,%-C%.%# %f 表示文件名，%l 表示行号， %m 表示错误信息，其它的还不能理解。 请参考 :help errorformat。 10.6 快速修改窗口 其实是 quickfix 插件提供的功能， 对编译调试程序非常有用 :copen -- 打开快速修改窗口。 :cclose -- 关闭快速修改窗口。 快速修改窗口在 make 程序时非常有用，当 make 之后： :cl -- 在快速修改窗口中列出错误。 :cn -- 定位到下一个错误。 :cp -- 定位到上一个错误。 :cr -- 定位到第一个错误。 10.7 自动补全 C-x C-s -- 拼写建议。 C-x C-v -- 补全 vim 选项和命令。 C-x C-l -- 整行补全。 C-x C-f -- 自动补全文件路径。弹出菜单后，按 C-f 循环选择，当然也可以按 C-n 和 C-p。 C-x C-p 和C-x C-n -- 用文档中出现过的单词补全当前的词。 直接按 C-p 和 C-n也可以。 C-x C-o -- 编程时可以补全关键字和函数名啊。 C-x C-i -- 根据头文件内关键字补全。 C-x C-d -- 补全宏定义。 C-x C-n -- 按缓冲区中出现过的关键字补全。 直接按 C-n 或 C-p 即可。 当弹出补全菜单后： C-p 向前切换成员； C-n 向后切换成员； C-e 退出下拉菜单，并退回到原来录入的文字； C-y 退出下拉菜单，并接受当前选项。 10.8 多行缩进缩出 正常模式下，按两下 >; 光标所在行会缩进。 如果先按了 n，再按两下 >;，光标以下的 n 行会缩进。 对应的，按两下 ，光标所在行会缩出。 如果在编辑代码文件，可以用 = 进行调整。 在可视模式下，选择要调整的代码块，按 =，代码会按书写规则缩排好。 或者 n =，调整 n 行代码的缩排。 10.9 折叠 zf -- 创建折叠的命令，可以在一个可视区域上使用该命令； zd -- 删除当前行的折叠； zD -- 删除当前行的折叠； zfap -- 折叠光标所在的段； zo -- 打开折叠的文本； zc -- 收起折叠； za -- 打开/关闭当前折叠； zr -- 打开嵌套的折行； zm -- 收起嵌套的折行； zR (zO) -- 打开所有折行； zM (zC) -- 收起所有折行； zj -- 跳到下一个折叠处； zk -- 跳到上一个折叠处； zi -- enable/disable fold; 10.10 zshrc配置脚本 $ vi ~/.zshrc ctags_fun() { ctags -R cscope -Rbqk return 0 } alias mctags=ctags_fun # define mctags ctags_cplus_fun() { find . -name \"*.h\" -o -name \"*.c\" -o -name \"*.cc\" -o -name \"*.cpp\" > cscope.files cscope -bkq -i cscope.files ctags -R --c++-kinds=+p --fields=+iaS --extra=+q return 0 } alias cplusctags=ctags_cplus_fun # define mctags 11. 其它 11.1 工作目录 :pwd 显示vim的工作目录。 :cd path 改变 vim 的工作目录。 :set autochdir 可以让 vim 根据编辑的文件自动切换工作目录。 11.2 一些快捷键（收集中） K : 打开光标所在词的 manpage。 * : 向下搜索光标所在词。 g* : 同上，但部分符合即可。 \\# : 向上搜索光标所在词。 g# : 同上，但部分符合即可。 g C-g : 统计全文或统计部分的字数。 11.3 在线帮助 :h(elp) 或 F1 打开总的帮助。 :help user-manual 打开用户手册。 命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。 :helptags somepath 为 somepath 中的文档生成索引。 :helpgrep 可以搜索整个帮助文档，匹配的列表显示在 quickfix 窗口中。 Ctrl+] 跳转到 tag 主题，Ctrl+t 跳回。 :ver 显示版本信息。 高亮所有搜索模式匹配 shift + * 向后搜索光标所在位置的单词 shift + # 向前搜索光标所在位置的单词 n 和 N 可以继续向后或者向前搜索匹配的字符串 :set hlsearch 高亮所有匹配的字符串 :nohlsearch 临时关闭 :set nohlsearch 彻底关闭，只有重新 :set hlsearch 才可以高亮搜索 vim 高亮显示光标所在的单词，在单词的地方输入 gd 语法高亮 syntax on syntax off vim自动补全 ctrl + n 或者 ctrl + p 复制 vim 文件中所有内容 gg 回到文件首 shift + v 进入 VISUAL LINE 模式 shift + g 全选所有内容 ctrl + insert 复制所选的内容 12 ctags 安装 Vim 配置 Catgs 用于前端开发 Ubuntu16.04安装配置和使用ctags 12.1 安装 universal-ctags universal-ctags 是一个现代化的ctag实现，本文只介绍使用Vim的安装方法 brew install --HEAD universal-ctags/universal-ctags/universal-ctags universal-ctags 是什么？A maintained ctags implementation, https://ctags.io, 一个负责的 ctags 实现，在github上开源并且持续更新和维护。 $ sudo apt install autoconf $ cd /tmp $ git clone https://github.com/universal-ctags/ctags $ cd ctags $ ./autogen.sh $ ./configure --prefix=/opt/software/universal-ctags # 我的安装路径。你按自己的情况调整。 $ make -j8 $ sudo make install 把 ctags 可执行文件更新到系统 PATH 上？No, 我选择创建链接的方式： # 如果你装了 emacs-snapshot，那么现在的 ctags 命令实际上链接到了 /usr/bin/ctags-snapshot，要先删除链接文件： # sudo rm /usr/bin/ctags # 然后，把新编译安装的 universal-ctags 链接过来： sudo ln -s /opt/software/universal-ctags/bin/ctags /usr/bin/ctags 其他系统请参考项目主页：ctags 每次生成ctags文件都要手动run一次命令，这一点也不Vim，当然也有解决方法。 12.2 安装vim-gutentags vim-gutentags 是一个用于自动生成 tag 文件的插件。使用 vim-plug 安装 Plug 'ludovicchabant/vim-gutentags' 12.3 配置 如果只是介绍安装方法，那就必要写这篇文章了，安装完成之后还是要针对前端开发的特点手动调教一下。首先我们在任何目录打开文件，都会在目录下生成 ctags 文件，这样的话对项目代码有入侵性，并不推荐，建议把 tag 文件写在特定的目录里。可以做如下设置： let g:gutentags_cache_dir = '~/.cachetags' 这样生成的 tags 文件会统一放在 ~/.cachetags 目录下。另外默认生成的文件名叫 tags，也可以根据个从喜好修改： let g:gutentags_ctags_tagfile = '.tags' 这样生成的文件是隐藏文件。另外一个很纠结的问题是有些文件我们并不想让他们生成 tags 文件，比如 node_modules 下文件，还有 .git 目录下的文件。这里有个取巧的方法是根据《Vim配置使用FZF》中的方法，把 ctags 获取文件列表的命令改成 ripgrep 的搜索，这样就可以自动忽略 .gitignore 下的文件。如下： let g:gutentags_file_list_command = 'rg --files' 另外有的文件我们也不想让其生成 ctags 文件，比如 *.md、*.svg 文件，可以通过 universal-ctags 的全局配置来配置，这里要注意的是 universal-ctags 默认的全局配置文件已经不是 ~/.ctags 和 ./.ctags，而是在 ~/.ctags.d/*.ctags 和 ./.ctags.d/*.ctags。比如我的全局配置文件放在~/.ctags.d/ignore.ctags。简要配置如下 ： --exclude=node_modules --exclude=gulp --exclude=.git --exclude=*.md --exclude=*.svg 12.4 结合FZF 在文章《Vim配置使用FZF》中的介绍，FZF 是支持 ctags 的，所以可以做个快捷键配置，如下： map t :Tags 这样就可以方便的使用 ctrl-] 和 ctrl-o 来进行 tag 跳转了。 13 Gtags Vim 8 中 C/C++ 符号索引：GTags Ubuntu 安裝 GNU Global(gtags) 阅读Linux内核源码 14. VIM 插件 vim 入坑指南（六）插件 UltiSnips "}}